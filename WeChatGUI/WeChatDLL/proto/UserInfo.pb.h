// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserInfo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_UserInfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_UserInfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_UserInfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_UserInfo_2eproto {
  static const uint32_t offsets[];
};
class DisturbSetting;
struct DisturbSettingDefaultTypeInternal;
extern DisturbSettingDefaultTypeInternal _DisturbSetting_default_instance_;
class DisturbTimeSpan;
struct DisturbTimeSpanDefaultTypeInternal;
extern DisturbTimeSpanDefaultTypeInternal _DisturbTimeSpan_default_instance_;
class FinderRingBackSetting;
struct FinderRingBackSettingDefaultTypeInternal;
extern FinderRingBackSettingDefaultTypeInternal _FinderRingBackSetting_default_instance_;
class GetProfileResponse;
struct GetProfileResponseDefaultTypeInternal;
extern GetProfileResponseDefaultTypeInternal _GetProfileResponse_default_instance_;
class GmailInfo;
struct GmailInfoDefaultTypeInternal;
extern GmailInfoDefaultTypeInternal _GmailInfo_default_instance_;
class GmailList;
struct GmailListDefaultTypeInternal;
extern GmailListDefaultTypeInternal _GmailList_default_instance_;
class LinkedinContactItem;
struct LinkedinContactItemDefaultTypeInternal;
extern LinkedinContactItemDefaultTypeInternal _LinkedinContactItem_default_instance_;
class ModUserInfo;
struct ModUserInfoDefaultTypeInternal;
extern ModUserInfoDefaultTypeInternal _ModUserInfo_default_instance_;
class MusicRingBackSetting;
struct MusicRingBackSettingDefaultTypeInternal;
extern MusicRingBackSettingDefaultTypeInternal _MusicRingBackSetting_default_instance_;
class NewRingBackSetting;
struct NewRingBackSettingDefaultTypeInternal;
extern NewRingBackSettingDefaultTypeInternal _NewRingBackSetting_default_instance_;
class PatternLockInfo;
struct PatternLockInfoDefaultTypeInternal;
extern PatternLockInfoDefaultTypeInternal _PatternLockInfo_default_instance_;
class RingBackSetting;
struct RingBackSettingDefaultTypeInternal;
extern RingBackSettingDefaultTypeInternal _RingBackSetting_default_instance_;
class SafeDevice;
struct SafeDeviceDefaultTypeInternal;
extern SafeDeviceDefaultTypeInternal _SafeDevice_default_instance_;
class SafeDeviceList;
struct SafeDeviceListDefaultTypeInternal;
extern SafeDeviceListDefaultTypeInternal _SafeDeviceList_default_instance_;
class SnsUserInfo;
struct SnsUserInfoDefaultTypeInternal;
extern SnsUserInfoDefaultTypeInternal _SnsUserInfo_default_instance_;
class UserInfoExt;
struct UserInfoExtDefaultTypeInternal;
extern UserInfoExtDefaultTypeInternal _UserInfoExt_default_instance_;
class XAgreementInfo;
struct XAgreementInfoDefaultTypeInternal;
extern XAgreementInfoDefaultTypeInternal _XAgreementInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::DisturbSetting* Arena::CreateMaybeMessage<::DisturbSetting>(Arena*);
template<> ::DisturbTimeSpan* Arena::CreateMaybeMessage<::DisturbTimeSpan>(Arena*);
template<> ::FinderRingBackSetting* Arena::CreateMaybeMessage<::FinderRingBackSetting>(Arena*);
template<> ::GetProfileResponse* Arena::CreateMaybeMessage<::GetProfileResponse>(Arena*);
template<> ::GmailInfo* Arena::CreateMaybeMessage<::GmailInfo>(Arena*);
template<> ::GmailList* Arena::CreateMaybeMessage<::GmailList>(Arena*);
template<> ::LinkedinContactItem* Arena::CreateMaybeMessage<::LinkedinContactItem>(Arena*);
template<> ::ModUserInfo* Arena::CreateMaybeMessage<::ModUserInfo>(Arena*);
template<> ::MusicRingBackSetting* Arena::CreateMaybeMessage<::MusicRingBackSetting>(Arena*);
template<> ::NewRingBackSetting* Arena::CreateMaybeMessage<::NewRingBackSetting>(Arena*);
template<> ::PatternLockInfo* Arena::CreateMaybeMessage<::PatternLockInfo>(Arena*);
template<> ::RingBackSetting* Arena::CreateMaybeMessage<::RingBackSetting>(Arena*);
template<> ::SafeDevice* Arena::CreateMaybeMessage<::SafeDevice>(Arena*);
template<> ::SafeDeviceList* Arena::CreateMaybeMessage<::SafeDeviceList>(Arena*);
template<> ::SnsUserInfo* Arena::CreateMaybeMessage<::SnsUserInfo>(Arena*);
template<> ::UserInfoExt* Arena::CreateMaybeMessage<::UserInfoExt>(Arena*);
template<> ::XAgreementInfo* Arena::CreateMaybeMessage<::XAgreementInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class GmailList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GmailList) */ {
 public:
  inline GmailList() : GmailList(nullptr) {}
  ~GmailList() override;
  explicit PROTOBUF_CONSTEXPR GmailList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GmailList(const GmailList& from);
  GmailList(GmailList&& from) noexcept
    : GmailList() {
    *this = ::std::move(from);
  }

  inline GmailList& operator=(const GmailList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GmailList& operator=(GmailList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GmailList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GmailList* internal_default_instance() {
    return reinterpret_cast<const GmailList*>(
               &_GmailList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GmailList& a, GmailList& b) {
    a.Swap(&b);
  }
  inline void Swap(GmailList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GmailList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GmailList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GmailList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GmailList& from);
  void MergeFrom(const GmailList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GmailList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GmailList";
  }
  protected:
  explicit GmailList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .GmailInfo list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::GmailInfo* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GmailInfo >*
      mutable_list();
  private:
  const ::GmailInfo& _internal_list(int index) const;
  ::GmailInfo* _internal_add_list();
  public:
  const ::GmailInfo& list(int index) const;
  ::GmailInfo* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GmailInfo >&
      list() const;

  // required uint32 count = 1;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GmailList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GmailInfo > list_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class MusicRingBackSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MusicRingBackSetting) */ {
 public:
  inline MusicRingBackSetting() : MusicRingBackSetting(nullptr) {}
  ~MusicRingBackSetting() override;
  explicit PROTOBUF_CONSTEXPR MusicRingBackSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MusicRingBackSetting(const MusicRingBackSetting& from);
  MusicRingBackSetting(MusicRingBackSetting&& from) noexcept
    : MusicRingBackSetting() {
    *this = ::std::move(from);
  }

  inline MusicRingBackSetting& operator=(const MusicRingBackSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline MusicRingBackSetting& operator=(MusicRingBackSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MusicRingBackSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const MusicRingBackSetting* internal_default_instance() {
    return reinterpret_cast<const MusicRingBackSetting*>(
               &_MusicRingBackSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MusicRingBackSetting& a, MusicRingBackSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(MusicRingBackSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MusicRingBackSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MusicRingBackSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MusicRingBackSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MusicRingBackSetting& from);
  void MergeFrom(const MusicRingBackSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MusicRingBackSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MusicRingBackSetting";
  }
  protected:
  explicit MusicRingBackSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
  };
  // optional uint32 sid = 1;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  uint32_t sid() const;
  void set_sid(uint32_t value);
  private:
  uint32_t _internal_sid() const;
  void _internal_set_sid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MusicRingBackSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class FinderRingBackSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:FinderRingBackSetting) */ {
 public:
  inline FinderRingBackSetting() : FinderRingBackSetting(nullptr) {}
  ~FinderRingBackSetting() override;
  explicit PROTOBUF_CONSTEXPR FinderRingBackSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinderRingBackSetting(const FinderRingBackSetting& from);
  FinderRingBackSetting(FinderRingBackSetting&& from) noexcept
    : FinderRingBackSetting() {
    *this = ::std::move(from);
  }

  inline FinderRingBackSetting& operator=(const FinderRingBackSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinderRingBackSetting& operator=(FinderRingBackSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FinderRingBackSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinderRingBackSetting* internal_default_instance() {
    return reinterpret_cast<const FinderRingBackSetting*>(
               &_FinderRingBackSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FinderRingBackSetting& a, FinderRingBackSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(FinderRingBackSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinderRingBackSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinderRingBackSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinderRingBackSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FinderRingBackSetting& from);
  void MergeFrom(const FinderRingBackSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FinderRingBackSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FinderRingBackSetting";
  }
  protected:
  explicit FinderRingBackSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinderNonceIdFieldNumber = 2,
    kFinderObjectIdFieldNumber = 1,
  };
  // optional string finderNonceId = 2;
  bool has_findernonceid() const;
  private:
  bool _internal_has_findernonceid() const;
  public:
  void clear_findernonceid();
  const std::string& findernonceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_findernonceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_findernonceid();
  PROTOBUF_NODISCARD std::string* release_findernonceid();
  void set_allocated_findernonceid(std::string* findernonceid);
  private:
  const std::string& _internal_findernonceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_findernonceid(const std::string& value);
  std::string* _internal_mutable_findernonceid();
  public:

  // optional uint64 finderObjectId = 1;
  bool has_finderobjectid() const;
  private:
  bool _internal_has_finderobjectid() const;
  public:
  void clear_finderobjectid();
  uint64_t finderobjectid() const;
  void set_finderobjectid(uint64_t value);
  private:
  uint64_t _internal_finderobjectid() const;
  void _internal_set_finderobjectid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:FinderRingBackSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr findernonceid_;
    uint64_t finderobjectid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class NewRingBackSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:NewRingBackSetting) */ {
 public:
  inline NewRingBackSetting() : NewRingBackSetting(nullptr) {}
  ~NewRingBackSetting() override;
  explicit PROTOBUF_CONSTEXPR NewRingBackSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRingBackSetting(const NewRingBackSetting& from);
  NewRingBackSetting(NewRingBackSetting&& from) noexcept
    : NewRingBackSetting() {
    *this = ::std::move(from);
  }

  inline NewRingBackSetting& operator=(const NewRingBackSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRingBackSetting& operator=(NewRingBackSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NewRingBackSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRingBackSetting* internal_default_instance() {
    return reinterpret_cast<const NewRingBackSetting*>(
               &_NewRingBackSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewRingBackSetting& a, NewRingBackSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRingBackSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRingBackSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRingBackSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRingBackSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NewRingBackSetting& from);
  void MergeFrom(const NewRingBackSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewRingBackSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NewRingBackSetting";
  }
  protected:
  explicit NewRingBackSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMusicFieldNumber = 4,
    kFinderFieldNumber = 5,
    kTypeFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // optional .MusicRingBackSetting music = 4;
  bool has_music() const;
  private:
  bool _internal_has_music() const;
  public:
  void clear_music();
  const ::MusicRingBackSetting& music() const;
  PROTOBUF_NODISCARD ::MusicRingBackSetting* release_music();
  ::MusicRingBackSetting* mutable_music();
  void set_allocated_music(::MusicRingBackSetting* music);
  private:
  const ::MusicRingBackSetting& _internal_music() const;
  ::MusicRingBackSetting* _internal_mutable_music();
  public:
  void unsafe_arena_set_allocated_music(
      ::MusicRingBackSetting* music);
  ::MusicRingBackSetting* unsafe_arena_release_music();

  // optional .FinderRingBackSetting finder = 5;
  bool has_finder() const;
  private:
  bool _internal_has_finder() const;
  public:
  void clear_finder();
  const ::FinderRingBackSetting& finder() const;
  PROTOBUF_NODISCARD ::FinderRingBackSetting* release_finder();
  ::FinderRingBackSetting* mutable_finder();
  void set_allocated_finder(::FinderRingBackSetting* finder);
  private:
  const ::FinderRingBackSetting& _internal_finder() const;
  ::FinderRingBackSetting* _internal_mutable_finder();
  public:
  void unsafe_arena_set_allocated_finder(
      ::FinderRingBackSetting* finder);
  ::FinderRingBackSetting* unsafe_arena_release_finder();

  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 startTime = 2;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  uint32_t starttime() const;
  void set_starttime(uint32_t value);
  private:
  uint32_t _internal_starttime() const;
  void _internal_set_starttime(uint32_t value);
  public:

  // optional uint32 endTime = 3;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  uint32_t endtime() const;
  void set_endtime(uint32_t value);
  private:
  uint32_t _internal_endtime() const;
  void _internal_set_endtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NewRingBackSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::MusicRingBackSetting* music_;
    ::FinderRingBackSetting* finder_;
    uint32_t type_;
    uint32_t starttime_;
    uint32_t endtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class RingBackSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:RingBackSetting) */ {
 public:
  inline RingBackSetting() : RingBackSetting(nullptr) {}
  ~RingBackSetting() override;
  explicit PROTOBUF_CONSTEXPR RingBackSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RingBackSetting(const RingBackSetting& from);
  RingBackSetting(RingBackSetting&& from) noexcept
    : RingBackSetting() {
    *this = ::std::move(from);
  }

  inline RingBackSetting& operator=(const RingBackSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingBackSetting& operator=(RingBackSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RingBackSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingBackSetting* internal_default_instance() {
    return reinterpret_cast<const RingBackSetting*>(
               &_RingBackSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RingBackSetting& a, RingBackSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(RingBackSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingBackSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingBackSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingBackSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RingBackSetting& from);
  void MergeFrom(const RingBackSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RingBackSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RingBackSetting";
  }
  protected:
  explicit RingBackSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinderNonceIdFieldNumber = 2,
    kFinderObjectIdFieldNumber = 1,
    kStartTsFieldNumber = 3,
    kEndTsFieldNumber = 4,
  };
  // required string finderNonceId = 2;
  bool has_findernonceid() const;
  private:
  bool _internal_has_findernonceid() const;
  public:
  void clear_findernonceid();
  const std::string& findernonceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_findernonceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_findernonceid();
  PROTOBUF_NODISCARD std::string* release_findernonceid();
  void set_allocated_findernonceid(std::string* findernonceid);
  private:
  const std::string& _internal_findernonceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_findernonceid(const std::string& value);
  std::string* _internal_mutable_findernonceid();
  public:

  // required uint64 finderObjectId = 1;
  bool has_finderobjectid() const;
  private:
  bool _internal_has_finderobjectid() const;
  public:
  void clear_finderobjectid();
  uint64_t finderobjectid() const;
  void set_finderobjectid(uint64_t value);
  private:
  uint64_t _internal_finderobjectid() const;
  void _internal_set_finderobjectid(uint64_t value);
  public:

  // required uint32 startTs = 3;
  bool has_startts() const;
  private:
  bool _internal_has_startts() const;
  public:
  void clear_startts();
  uint32_t startts() const;
  void set_startts(uint32_t value);
  private:
  uint32_t _internal_startts() const;
  void _internal_set_startts(uint32_t value);
  public:

  // required uint32 endTs = 4;
  bool has_endts() const;
  private:
  bool _internal_has_endts() const;
  public:
  void clear_endts();
  uint32_t endts() const;
  void set_endts(uint32_t value);
  private:
  uint32_t _internal_endts() const;
  void _internal_set_endts(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RingBackSetting)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr findernonceid_;
    uint64_t finderobjectid_;
    uint32_t startts_;
    uint32_t endts_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class XAgreementInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:XAgreementInfo) */ {
 public:
  inline XAgreementInfo() : XAgreementInfo(nullptr) {}
  ~XAgreementInfo() override;
  explicit PROTOBUF_CONSTEXPR XAgreementInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XAgreementInfo(const XAgreementInfo& from);
  XAgreementInfo(XAgreementInfo&& from) noexcept
    : XAgreementInfo() {
    *this = ::std::move(from);
  }

  inline XAgreementInfo& operator=(const XAgreementInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline XAgreementInfo& operator=(XAgreementInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const XAgreementInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const XAgreementInfo* internal_default_instance() {
    return reinterpret_cast<const XAgreementInfo*>(
               &_XAgreementInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(XAgreementInfo& a, XAgreementInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(XAgreementInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XAgreementInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XAgreementInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XAgreementInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const XAgreementInfo& from);
  void MergeFrom(const XAgreementInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XAgreementInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XAgreementInfo";
  }
  protected:
  explicit XAgreementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncsSwitchFieldNumber = 1,
    kFuncsUserChoiceSwitchFieldNumber = 2,
  };
  // optional uint64 funcsSwitch = 1;
  bool has_funcsswitch() const;
  private:
  bool _internal_has_funcsswitch() const;
  public:
  void clear_funcsswitch();
  uint64_t funcsswitch() const;
  void set_funcsswitch(uint64_t value);
  private:
  uint64_t _internal_funcsswitch() const;
  void _internal_set_funcsswitch(uint64_t value);
  public:

  // optional uint64 funcsUserChoiceSwitch = 2;
  bool has_funcsuserchoiceswitch() const;
  private:
  bool _internal_has_funcsuserchoiceswitch() const;
  public:
  void clear_funcsuserchoiceswitch();
  uint64_t funcsuserchoiceswitch() const;
  void set_funcsuserchoiceswitch(uint64_t value);
  private:
  uint64_t _internal_funcsuserchoiceswitch() const;
  void _internal_set_funcsuserchoiceswitch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XAgreementInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t funcsswitch_;
    uint64_t funcsuserchoiceswitch_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class LinkedinContactItem final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:LinkedinContactItem) */ {
 public:
  inline LinkedinContactItem() : LinkedinContactItem(nullptr) {}
  ~LinkedinContactItem() override;
  explicit PROTOBUF_CONSTEXPR LinkedinContactItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkedinContactItem(const LinkedinContactItem& from);
  LinkedinContactItem(LinkedinContactItem&& from) noexcept
    : LinkedinContactItem() {
    *this = ::std::move(from);
  }

  inline LinkedinContactItem& operator=(const LinkedinContactItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkedinContactItem& operator=(LinkedinContactItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LinkedinContactItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkedinContactItem* internal_default_instance() {
    return reinterpret_cast<const LinkedinContactItem*>(
               &_LinkedinContactItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LinkedinContactItem& a, LinkedinContactItem& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkedinContactItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkedinContactItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkedinContactItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkedinContactItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LinkedinContactItem& from);
  void MergeFrom(const LinkedinContactItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinkedinContactItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LinkedinContactItem";
  }
  protected:
  explicit LinkedinContactItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkedinNameFieldNumber = 1,
    kLinkedinMemberIdFieldNumber = 2,
    kLinkedinPublicUrlFieldNumber = 3,
  };
  // optional string linkedinName = 1;
  bool has_linkedinname() const;
  private:
  bool _internal_has_linkedinname() const;
  public:
  void clear_linkedinname();
  const std::string& linkedinname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedinname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedinname();
  PROTOBUF_NODISCARD std::string* release_linkedinname();
  void set_allocated_linkedinname(std::string* linkedinname);
  private:
  const std::string& _internal_linkedinname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedinname(const std::string& value);
  std::string* _internal_mutable_linkedinname();
  public:

  // optional string linkedinMemberId = 2;
  bool has_linkedinmemberid() const;
  private:
  bool _internal_has_linkedinmemberid() const;
  public:
  void clear_linkedinmemberid();
  const std::string& linkedinmemberid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedinmemberid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedinmemberid();
  PROTOBUF_NODISCARD std::string* release_linkedinmemberid();
  void set_allocated_linkedinmemberid(std::string* linkedinmemberid);
  private:
  const std::string& _internal_linkedinmemberid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedinmemberid(const std::string& value);
  std::string* _internal_mutable_linkedinmemberid();
  public:

  // optional string linkedinPublicUrl = 3;
  bool has_linkedinpublicurl() const;
  private:
  bool _internal_has_linkedinpublicurl() const;
  public:
  void clear_linkedinpublicurl();
  const std::string& linkedinpublicurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedinpublicurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedinpublicurl();
  PROTOBUF_NODISCARD std::string* release_linkedinpublicurl();
  void set_allocated_linkedinpublicurl(std::string* linkedinpublicurl);
  private:
  const std::string& _internal_linkedinpublicurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedinpublicurl(const std::string& value);
  std::string* _internal_mutable_linkedinpublicurl();
  public:

  // @@protoc_insertion_point(class_scope:LinkedinContactItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedinname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedinmemberid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedinpublicurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class PatternLockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PatternLockInfo) */ {
 public:
  inline PatternLockInfo() : PatternLockInfo(nullptr) {}
  ~PatternLockInfo() override;
  explicit PROTOBUF_CONSTEXPR PatternLockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatternLockInfo(const PatternLockInfo& from);
  PatternLockInfo(PatternLockInfo&& from) noexcept
    : PatternLockInfo() {
    *this = ::std::move(from);
  }

  inline PatternLockInfo& operator=(const PatternLockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternLockInfo& operator=(PatternLockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PatternLockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternLockInfo* internal_default_instance() {
    return reinterpret_cast<const PatternLockInfo*>(
               &_PatternLockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PatternLockInfo& a, PatternLockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternLockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternLockInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternLockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternLockInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PatternLockInfo& from);
  void MergeFrom(const PatternLockInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PatternLockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PatternLockInfo";
  }
  protected:
  explicit PatternLockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignFieldNumber = 2,
    kPatternVersionFieldNumber = 1,
    kLockStatusFieldNumber = 3,
  };
  // optional .SKBuiltinBuffer_t sign = 2;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::SKBuiltinBuffer_t& sign() const;
  PROTOBUF_NODISCARD ::SKBuiltinBuffer_t* release_sign();
  ::SKBuiltinBuffer_t* mutable_sign();
  void set_allocated_sign(::SKBuiltinBuffer_t* sign);
  private:
  const ::SKBuiltinBuffer_t& _internal_sign() const;
  ::SKBuiltinBuffer_t* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::SKBuiltinBuffer_t* sign);
  ::SKBuiltinBuffer_t* unsafe_arena_release_sign();

  // optional uint32 patternVersion = 1;
  bool has_patternversion() const;
  private:
  bool _internal_has_patternversion() const;
  public:
  void clear_patternversion();
  uint32_t patternversion() const;
  void set_patternversion(uint32_t value);
  private:
  uint32_t _internal_patternversion() const;
  void _internal_set_patternversion(uint32_t value);
  public:

  // optional uint32 lockStatus = 3;
  bool has_lockstatus() const;
  private:
  bool _internal_has_lockstatus() const;
  public:
  void clear_lockstatus();
  uint32_t lockstatus() const;
  void set_lockstatus(uint32_t value);
  private:
  uint32_t _internal_lockstatus() const;
  void _internal_set_lockstatus(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PatternLockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SKBuiltinBuffer_t* sign_;
    uint32_t patternversion_;
    uint32_t lockstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class SafeDevice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SafeDevice) */ {
 public:
  inline SafeDevice() : SafeDevice(nullptr) {}
  ~SafeDevice() override;
  explicit PROTOBUF_CONSTEXPR SafeDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafeDevice(const SafeDevice& from);
  SafeDevice(SafeDevice&& from) noexcept
    : SafeDevice() {
    *this = ::std::move(from);
  }

  inline SafeDevice& operator=(const SafeDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafeDevice& operator=(SafeDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SafeDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafeDevice* internal_default_instance() {
    return reinterpret_cast<const SafeDevice*>(
               &_SafeDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SafeDevice& a, SafeDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(SafeDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafeDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafeDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafeDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SafeDevice& from);
  void MergeFrom(const SafeDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SafeDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SafeDevice";
  }
  protected:
  explicit SafeDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUuidFieldNumber = 2,
    kDeviceTypeFieldNumber = 3,
    kCreateTimeFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string uuid = 2;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // optional string deviceType = 3;
  bool has_devicetype() const;
  private:
  bool _internal_has_devicetype() const;
  public:
  void clear_devicetype();
  const std::string& devicetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicetype();
  PROTOBUF_NODISCARD std::string* release_devicetype();
  void set_allocated_devicetype(std::string* devicetype);
  private:
  const std::string& _internal_devicetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicetype(const std::string& value);
  std::string* _internal_mutable_devicetype();
  public:

  // required uint32 createTime = 4;
  bool has_createtime() const;
  private:
  bool _internal_has_createtime() const;
  public:
  void clear_createtime();
  uint32_t createtime() const;
  void set_createtime(uint32_t value);
  private:
  uint32_t _internal_createtime() const;
  void _internal_set_createtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SafeDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicetype_;
    uint32_t createtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class SafeDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SafeDeviceList) */ {
 public:
  inline SafeDeviceList() : SafeDeviceList(nullptr) {}
  ~SafeDeviceList() override;
  explicit PROTOBUF_CONSTEXPR SafeDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafeDeviceList(const SafeDeviceList& from);
  SafeDeviceList(SafeDeviceList&& from) noexcept
    : SafeDeviceList() {
    *this = ::std::move(from);
  }

  inline SafeDeviceList& operator=(const SafeDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafeDeviceList& operator=(SafeDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SafeDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafeDeviceList* internal_default_instance() {
    return reinterpret_cast<const SafeDeviceList*>(
               &_SafeDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SafeDeviceList& a, SafeDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(SafeDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafeDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafeDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafeDeviceList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SafeDeviceList& from);
  void MergeFrom(const SafeDeviceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SafeDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SafeDeviceList";
  }
  protected:
  explicit SafeDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .SafeDevice list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::SafeDevice* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SafeDevice >*
      mutable_list();
  private:
  const ::SafeDevice& _internal_list(int index) const;
  ::SafeDevice* _internal_add_list();
  public:
  const ::SafeDevice& list(int index) const;
  ::SafeDevice* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SafeDevice >&
      list() const;

  // required uint32 count = 1;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SafeDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SafeDevice > list_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class SnsUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:SnsUserInfo) */ {
 public:
  inline SnsUserInfo() : SnsUserInfo(nullptr) {}
  ~SnsUserInfo() override;
  explicit PROTOBUF_CONSTEXPR SnsUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnsUserInfo(const SnsUserInfo& from);
  SnsUserInfo(SnsUserInfo&& from) noexcept
    : SnsUserInfo() {
    *this = ::std::move(from);
  }

  inline SnsUserInfo& operator=(const SnsUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnsUserInfo& operator=(SnsUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SnsUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnsUserInfo* internal_default_instance() {
    return reinterpret_cast<const SnsUserInfo*>(
               &_SnsUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SnsUserInfo& a, SnsUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SnsUserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnsUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnsUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnsUserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SnsUserInfo& from);
  void MergeFrom(const SnsUserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SnsUserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SnsUserInfo";
  }
  protected:
  explicit SnsUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnsBgimgIdFieldNumber = 2,
    kSnsFlagFieldNumber = 1,
    kSnsFlagExFieldNumber = 4,
    kSnsBgobjectIdFieldNumber = 3,
    kSnsPrivacyRecentFieldNumber = 5,
  };
  // optional string snsBgimgId = 2;
  bool has_snsbgimgid() const;
  private:
  bool _internal_has_snsbgimgid() const;
  public:
  void clear_snsbgimgid();
  const std::string& snsbgimgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snsbgimgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snsbgimgid();
  PROTOBUF_NODISCARD std::string* release_snsbgimgid();
  void set_allocated_snsbgimgid(std::string* snsbgimgid);
  private:
  const std::string& _internal_snsbgimgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snsbgimgid(const std::string& value);
  std::string* _internal_mutable_snsbgimgid();
  public:

  // required uint32 snsFlag = 1;
  bool has_snsflag() const;
  private:
  bool _internal_has_snsflag() const;
  public:
  void clear_snsflag();
  uint32_t snsflag() const;
  void set_snsflag(uint32_t value);
  private:
  uint32_t _internal_snsflag() const;
  void _internal_set_snsflag(uint32_t value);
  public:

  // optional uint32 snsFlagEx = 4;
  bool has_snsflagex() const;
  private:
  bool _internal_has_snsflagex() const;
  public:
  void clear_snsflagex();
  uint32_t snsflagex() const;
  void set_snsflagex(uint32_t value);
  private:
  uint32_t _internal_snsflagex() const;
  void _internal_set_snsflagex(uint32_t value);
  public:

  // optional uint64 snsBgobjectId = 3;
  bool has_snsbgobjectid() const;
  private:
  bool _internal_has_snsbgobjectid() const;
  public:
  void clear_snsbgobjectid();
  uint64_t snsbgobjectid() const;
  void set_snsbgobjectid(uint64_t value);
  private:
  uint64_t _internal_snsbgobjectid() const;
  void _internal_set_snsbgobjectid(uint64_t value);
  public:

  // optional uint32 snsPrivacyRecent = 5;
  bool has_snsprivacyrecent() const;
  private:
  bool _internal_has_snsprivacyrecent() const;
  public:
  void clear_snsprivacyrecent();
  uint32_t snsprivacyrecent() const;
  void set_snsprivacyrecent(uint32_t value);
  private:
  uint32_t _internal_snsprivacyrecent() const;
  void _internal_set_snsprivacyrecent(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SnsUserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snsbgimgid_;
    uint32_t snsflag_;
    uint32_t snsflagex_;
    uint64_t snsbgobjectid_;
    uint32_t snsprivacyrecent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class GmailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GmailInfo) */ {
 public:
  inline GmailInfo() : GmailInfo(nullptr) {}
  ~GmailInfo() override;
  explicit PROTOBUF_CONSTEXPR GmailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GmailInfo(const GmailInfo& from);
  GmailInfo(GmailInfo&& from) noexcept
    : GmailInfo() {
    *this = ::std::move(from);
  }

  inline GmailInfo& operator=(const GmailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GmailInfo& operator=(GmailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GmailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GmailInfo* internal_default_instance() {
    return reinterpret_cast<const GmailInfo*>(
               &_GmailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GmailInfo& a, GmailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GmailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GmailInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GmailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GmailInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GmailInfo& from);
  void MergeFrom(const GmailInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GmailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GmailInfo";
  }
  protected:
  explicit GmailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGmailAcctFieldNumber = 1,
    kGmailSwitchFieldNumber = 2,
    kGmailErrCodeFieldNumber = 3,
  };
  // optional string gmailAcct = 1;
  bool has_gmailacct() const;
  private:
  bool _internal_has_gmailacct() const;
  public:
  void clear_gmailacct();
  const std::string& gmailacct() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gmailacct(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gmailacct();
  PROTOBUF_NODISCARD std::string* release_gmailacct();
  void set_allocated_gmailacct(std::string* gmailacct);
  private:
  const std::string& _internal_gmailacct() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gmailacct(const std::string& value);
  std::string* _internal_mutable_gmailacct();
  public:

  // required uint32 gmailSwitch = 2;
  bool has_gmailswitch() const;
  private:
  bool _internal_has_gmailswitch() const;
  public:
  void clear_gmailswitch();
  uint32_t gmailswitch() const;
  void set_gmailswitch(uint32_t value);
  private:
  uint32_t _internal_gmailswitch() const;
  void _internal_set_gmailswitch(uint32_t value);
  public:

  // required uint32 gmailErrCode = 3;
  bool has_gmailerrcode() const;
  private:
  bool _internal_has_gmailerrcode() const;
  public:
  void clear_gmailerrcode();
  uint32_t gmailerrcode() const;
  void set_gmailerrcode(uint32_t value);
  private:
  uint32_t _internal_gmailerrcode() const;
  void _internal_set_gmailerrcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GmailInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gmailacct_;
    uint32_t gmailswitch_;
    uint32_t gmailerrcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class DisturbTimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DisturbTimeSpan) */ {
 public:
  inline DisturbTimeSpan() : DisturbTimeSpan(nullptr) {}
  ~DisturbTimeSpan() override;
  explicit PROTOBUF_CONSTEXPR DisturbTimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisturbTimeSpan(const DisturbTimeSpan& from);
  DisturbTimeSpan(DisturbTimeSpan&& from) noexcept
    : DisturbTimeSpan() {
    *this = ::std::move(from);
  }

  inline DisturbTimeSpan& operator=(const DisturbTimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisturbTimeSpan& operator=(DisturbTimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisturbTimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisturbTimeSpan* internal_default_instance() {
    return reinterpret_cast<const DisturbTimeSpan*>(
               &_DisturbTimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DisturbTimeSpan& a, DisturbTimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(DisturbTimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisturbTimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisturbTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisturbTimeSpan>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisturbTimeSpan& from);
  void MergeFrom(const DisturbTimeSpan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisturbTimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DisturbTimeSpan";
  }
  protected:
  explicit DisturbTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // required uint32 beginTime = 1;
  bool has_begintime() const;
  private:
  bool _internal_has_begintime() const;
  public:
  void clear_begintime();
  uint32_t begintime() const;
  void set_begintime(uint32_t value);
  private:
  uint32_t _internal_begintime() const;
  void _internal_set_begintime(uint32_t value);
  public:

  // required uint32 endTime = 2;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  uint32_t endtime() const;
  void set_endtime(uint32_t value);
  private:
  uint32_t _internal_endtime() const;
  void _internal_set_endtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DisturbTimeSpan)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t begintime_;
    uint32_t endtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class DisturbSetting final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:DisturbSetting) */ {
 public:
  inline DisturbSetting() : DisturbSetting(nullptr) {}
  ~DisturbSetting() override;
  explicit PROTOBUF_CONSTEXPR DisturbSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisturbSetting(const DisturbSetting& from);
  DisturbSetting(DisturbSetting&& from) noexcept
    : DisturbSetting() {
    *this = ::std::move(from);
  }

  inline DisturbSetting& operator=(const DisturbSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisturbSetting& operator=(DisturbSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisturbSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisturbSetting* internal_default_instance() {
    return reinterpret_cast<const DisturbSetting*>(
               &_DisturbSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DisturbSetting& a, DisturbSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(DisturbSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisturbSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisturbSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisturbSetting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisturbSetting& from);
  void MergeFrom(const DisturbSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisturbSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DisturbSetting";
  }
  protected:
  explicit DisturbSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNightTimeFieldNumber = 2,
    kAllDayTimeFieldNumber = 4,
    kNightSettingFieldNumber = 1,
    kAllDaySettingFieldNumber = 3,
  };
  // required .DisturbTimeSpan nightTime = 2;
  bool has_nighttime() const;
  private:
  bool _internal_has_nighttime() const;
  public:
  void clear_nighttime();
  const ::DisturbTimeSpan& nighttime() const;
  PROTOBUF_NODISCARD ::DisturbTimeSpan* release_nighttime();
  ::DisturbTimeSpan* mutable_nighttime();
  void set_allocated_nighttime(::DisturbTimeSpan* nighttime);
  private:
  const ::DisturbTimeSpan& _internal_nighttime() const;
  ::DisturbTimeSpan* _internal_mutable_nighttime();
  public:
  void unsafe_arena_set_allocated_nighttime(
      ::DisturbTimeSpan* nighttime);
  ::DisturbTimeSpan* unsafe_arena_release_nighttime();

  // required .DisturbTimeSpan allDayTime = 4;
  bool has_alldaytime() const;
  private:
  bool _internal_has_alldaytime() const;
  public:
  void clear_alldaytime();
  const ::DisturbTimeSpan& alldaytime() const;
  PROTOBUF_NODISCARD ::DisturbTimeSpan* release_alldaytime();
  ::DisturbTimeSpan* mutable_alldaytime();
  void set_allocated_alldaytime(::DisturbTimeSpan* alldaytime);
  private:
  const ::DisturbTimeSpan& _internal_alldaytime() const;
  ::DisturbTimeSpan* _internal_mutable_alldaytime();
  public:
  void unsafe_arena_set_allocated_alldaytime(
      ::DisturbTimeSpan* alldaytime);
  ::DisturbTimeSpan* unsafe_arena_release_alldaytime();

  // required uint32 nightSetting = 1;
  bool has_nightsetting() const;
  private:
  bool _internal_has_nightsetting() const;
  public:
  void clear_nightsetting();
  uint32_t nightsetting() const;
  void set_nightsetting(uint32_t value);
  private:
  uint32_t _internal_nightsetting() const;
  void _internal_set_nightsetting(uint32_t value);
  public:

  // required uint32 allDaySetting = 3;
  bool has_alldaysetting() const;
  private:
  bool _internal_has_alldaysetting() const;
  public:
  void clear_alldaysetting();
  uint32_t alldaysetting() const;
  void set_alldaysetting(uint32_t value);
  private:
  uint32_t _internal_alldaysetting() const;
  void _internal_set_alldaysetting(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DisturbSetting)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DisturbTimeSpan* nighttime_;
    ::DisturbTimeSpan* alldaytime_;
    uint32_t nightsetting_;
    uint32_t alldaysetting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class ModUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ModUserInfo) */ {
 public:
  inline ModUserInfo() : ModUserInfo(nullptr) {}
  ~ModUserInfo() override;
  explicit PROTOBUF_CONSTEXPR ModUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModUserInfo(const ModUserInfo& from);
  ModUserInfo(ModUserInfo&& from) noexcept
    : ModUserInfo() {
    *this = ::std::move(from);
  }

  inline ModUserInfo& operator=(const ModUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModUserInfo& operator=(ModUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModUserInfo* internal_default_instance() {
    return reinterpret_cast<const ModUserInfo*>(
               &_ModUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ModUserInfo& a, ModUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModUserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModUserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModUserInfo& from);
  void MergeFrom(const ModUserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModUserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModUserInfo";
  }
  protected:
  explicit ModUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImgBufFieldNumber = 9,
    kProvinceFieldNumber = 11,
    kCityFieldNumber = 12,
    kSignatureFieldNumber = 13,
    kVerifyInfoFieldNumber = 18,
    kWeiboFieldNumber = 24,
    kAliasFieldNumber = 27,
    kWeiboNicknameFieldNumber = 28,
    kFbuserNameFieldNumber = 32,
    kAlbumBgimgIdFieldNumber = 35,
    kFbtokenFieldNumber = 37,
    kCountryFieldNumber = 38,
    kUserNameFieldNumber = 2,
    kNickNameFieldNumber = 3,
    kBindEmailFieldNumber = 5,
    kBindMobileFieldNumber = 6,
    kDisturbSettingFieldNumber = 15,
    kGmailListFieldNumber = 26,
    kBitFlagFieldNumber = 1,
    kBindUinFieldNumber = 4,
    kStatusFieldNumber = 7,
    kImgLenFieldNumber = 8,
    kSexFieldNumber = 10,
    kPersonalCardFieldNumber = 14,
    kPluginFlagFieldNumber = 16,
    kVerifyFlagFieldNumber = 17,
    kPointFieldNumber = 19,
    kExperienceFieldNumber = 20,
    kLevelFieldNumber = 21,
    kLevelLowExpFieldNumber = 22,
    kLevelHighExpFieldNumber = 23,
    kPluginSwitchFieldNumber = 25,
    kWeiboFlagFieldNumber = 29,
    kFaceBookFlagFieldNumber = 30,
    kFbuserIdFieldNumber = 31,
    kAlbumStyleFieldNumber = 33,
    kAlbumFlagFieldNumber = 34,
    kTxnewsCategoryFieldNumber = 36,
  };
  // optional bytes imgBuf = 9;
  bool has_imgbuf() const;
  private:
  bool _internal_has_imgbuf() const;
  public:
  void clear_imgbuf();
  const std::string& imgbuf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imgbuf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imgbuf();
  PROTOBUF_NODISCARD std::string* release_imgbuf();
  void set_allocated_imgbuf(std::string* imgbuf);
  private:
  const std::string& _internal_imgbuf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imgbuf(const std::string& value);
  std::string* _internal_mutable_imgbuf();
  public:

  // optional string province = 11;
  bool has_province() const;
  private:
  bool _internal_has_province() const;
  public:
  void clear_province();
  const std::string& province() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_province(ArgT0&& arg0, ArgT... args);
  std::string* mutable_province();
  PROTOBUF_NODISCARD std::string* release_province();
  void set_allocated_province(std::string* province);
  private:
  const std::string& _internal_province() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_province(const std::string& value);
  std::string* _internal_mutable_province();
  public:

  // optional string city = 12;
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // optional string signature = 13;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional string verifyInfo = 18;
  bool has_verifyinfo() const;
  private:
  bool _internal_has_verifyinfo() const;
  public:
  void clear_verifyinfo();
  const std::string& verifyinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifyinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifyinfo();
  PROTOBUF_NODISCARD std::string* release_verifyinfo();
  void set_allocated_verifyinfo(std::string* verifyinfo);
  private:
  const std::string& _internal_verifyinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifyinfo(const std::string& value);
  std::string* _internal_mutable_verifyinfo();
  public:

  // optional string weibo = 24;
  bool has_weibo() const;
  private:
  bool _internal_has_weibo() const;
  public:
  void clear_weibo();
  const std::string& weibo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weibo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weibo();
  PROTOBUF_NODISCARD std::string* release_weibo();
  void set_allocated_weibo(std::string* weibo);
  private:
  const std::string& _internal_weibo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weibo(const std::string& value);
  std::string* _internal_mutable_weibo();
  public:

  // optional string alias = 27;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;
  public:
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // optional string weiboNickname = 28;
  bool has_weibonickname() const;
  private:
  bool _internal_has_weibonickname() const;
  public:
  void clear_weibonickname();
  const std::string& weibonickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weibonickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weibonickname();
  PROTOBUF_NODISCARD std::string* release_weibonickname();
  void set_allocated_weibonickname(std::string* weibonickname);
  private:
  const std::string& _internal_weibonickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weibonickname(const std::string& value);
  std::string* _internal_mutable_weibonickname();
  public:

  // optional string fbuserName = 32;
  bool has_fbusername() const;
  private:
  bool _internal_has_fbusername() const;
  public:
  void clear_fbusername();
  const std::string& fbusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fbusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fbusername();
  PROTOBUF_NODISCARD std::string* release_fbusername();
  void set_allocated_fbusername(std::string* fbusername);
  private:
  const std::string& _internal_fbusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fbusername(const std::string& value);
  std::string* _internal_mutable_fbusername();
  public:

  // optional string albumBgimgId = 35;
  bool has_albumbgimgid() const;
  private:
  bool _internal_has_albumbgimgid() const;
  public:
  void clear_albumbgimgid();
  const std::string& albumbgimgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_albumbgimgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_albumbgimgid();
  PROTOBUF_NODISCARD std::string* release_albumbgimgid();
  void set_allocated_albumbgimgid(std::string* albumbgimgid);
  private:
  const std::string& _internal_albumbgimgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_albumbgimgid(const std::string& value);
  std::string* _internal_mutable_albumbgimgid();
  public:

  // optional string fbtoken = 37;
  bool has_fbtoken() const;
  private:
  bool _internal_has_fbtoken() const;
  public:
  void clear_fbtoken();
  const std::string& fbtoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fbtoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fbtoken();
  PROTOBUF_NODISCARD std::string* release_fbtoken();
  void set_allocated_fbtoken(std::string* fbtoken);
  private:
  const std::string& _internal_fbtoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fbtoken(const std::string& value);
  std::string* _internal_mutable_fbtoken();
  public:

  // optional string country = 38;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // required .SKBuiltinString_t userName = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const ::SKBuiltinString_t& username() const;
  PROTOBUF_NODISCARD ::SKBuiltinString_t* release_username();
  ::SKBuiltinString_t* mutable_username();
  void set_allocated_username(::SKBuiltinString_t* username);
  private:
  const ::SKBuiltinString_t& _internal_username() const;
  ::SKBuiltinString_t* _internal_mutable_username();
  public:
  void unsafe_arena_set_allocated_username(
      ::SKBuiltinString_t* username);
  ::SKBuiltinString_t* unsafe_arena_release_username();

  // required .SKBuiltinString_t nickName = 3;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const ::SKBuiltinString_t& nickname() const;
  PROTOBUF_NODISCARD ::SKBuiltinString_t* release_nickname();
  ::SKBuiltinString_t* mutable_nickname();
  void set_allocated_nickname(::SKBuiltinString_t* nickname);
  private:
  const ::SKBuiltinString_t& _internal_nickname() const;
  ::SKBuiltinString_t* _internal_mutable_nickname();
  public:
  void unsafe_arena_set_allocated_nickname(
      ::SKBuiltinString_t* nickname);
  ::SKBuiltinString_t* unsafe_arena_release_nickname();

  // required .SKBuiltinString_t bindEmail = 5;
  bool has_bindemail() const;
  private:
  bool _internal_has_bindemail() const;
  public:
  void clear_bindemail();
  const ::SKBuiltinString_t& bindemail() const;
  PROTOBUF_NODISCARD ::SKBuiltinString_t* release_bindemail();
  ::SKBuiltinString_t* mutable_bindemail();
  void set_allocated_bindemail(::SKBuiltinString_t* bindemail);
  private:
  const ::SKBuiltinString_t& _internal_bindemail() const;
  ::SKBuiltinString_t* _internal_mutable_bindemail();
  public:
  void unsafe_arena_set_allocated_bindemail(
      ::SKBuiltinString_t* bindemail);
  ::SKBuiltinString_t* unsafe_arena_release_bindemail();

  // required .SKBuiltinString_t bindMobile = 6;
  bool has_bindmobile() const;
  private:
  bool _internal_has_bindmobile() const;
  public:
  void clear_bindmobile();
  const ::SKBuiltinString_t& bindmobile() const;
  PROTOBUF_NODISCARD ::SKBuiltinString_t* release_bindmobile();
  ::SKBuiltinString_t* mutable_bindmobile();
  void set_allocated_bindmobile(::SKBuiltinString_t* bindmobile);
  private:
  const ::SKBuiltinString_t& _internal_bindmobile() const;
  ::SKBuiltinString_t* _internal_mutable_bindmobile();
  public:
  void unsafe_arena_set_allocated_bindmobile(
      ::SKBuiltinString_t* bindmobile);
  ::SKBuiltinString_t* unsafe_arena_release_bindmobile();

  // optional .DisturbSetting disturbSetting = 15;
  bool has_disturbsetting() const;
  private:
  bool _internal_has_disturbsetting() const;
  public:
  void clear_disturbsetting();
  const ::DisturbSetting& disturbsetting() const;
  PROTOBUF_NODISCARD ::DisturbSetting* release_disturbsetting();
  ::DisturbSetting* mutable_disturbsetting();
  void set_allocated_disturbsetting(::DisturbSetting* disturbsetting);
  private:
  const ::DisturbSetting& _internal_disturbsetting() const;
  ::DisturbSetting* _internal_mutable_disturbsetting();
  public:
  void unsafe_arena_set_allocated_disturbsetting(
      ::DisturbSetting* disturbsetting);
  ::DisturbSetting* unsafe_arena_release_disturbsetting();

  // optional .GmailList gmailList = 26;
  bool has_gmaillist() const;
  private:
  bool _internal_has_gmaillist() const;
  public:
  void clear_gmaillist();
  const ::GmailList& gmaillist() const;
  PROTOBUF_NODISCARD ::GmailList* release_gmaillist();
  ::GmailList* mutable_gmaillist();
  void set_allocated_gmaillist(::GmailList* gmaillist);
  private:
  const ::GmailList& _internal_gmaillist() const;
  ::GmailList* _internal_mutable_gmaillist();
  public:
  void unsafe_arena_set_allocated_gmaillist(
      ::GmailList* gmaillist);
  ::GmailList* unsafe_arena_release_gmaillist();

  // required uint32 bitFlag = 1;
  bool has_bitflag() const;
  private:
  bool _internal_has_bitflag() const;
  public:
  void clear_bitflag();
  uint32_t bitflag() const;
  void set_bitflag(uint32_t value);
  private:
  uint32_t _internal_bitflag() const;
  void _internal_set_bitflag(uint32_t value);
  public:

  // required uint32 bindUin = 4;
  bool has_binduin() const;
  private:
  bool _internal_has_binduin() const;
  public:
  void clear_binduin();
  uint32_t binduin() const;
  void set_binduin(uint32_t value);
  private:
  uint32_t _internal_binduin() const;
  void _internal_set_binduin(uint32_t value);
  public:

  // required uint32 status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // required uint32 imgLen = 8;
  bool has_imglen() const;
  private:
  bool _internal_has_imglen() const;
  public:
  void clear_imglen();
  uint32_t imglen() const;
  void set_imglen(uint32_t value);
  private:
  uint32_t _internal_imglen() const;
  void _internal_set_imglen(uint32_t value);
  public:

  // optional int32 sex = 10;
  bool has_sex() const;
  private:
  bool _internal_has_sex() const;
  public:
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // optional uint32 personalCard = 14;
  bool has_personalcard() const;
  private:
  bool _internal_has_personalcard() const;
  public:
  void clear_personalcard();
  uint32_t personalcard() const;
  void set_personalcard(uint32_t value);
  private:
  uint32_t _internal_personalcard() const;
  void _internal_set_personalcard(uint32_t value);
  public:

  // optional uint32 pluginFlag = 16;
  bool has_pluginflag() const;
  private:
  bool _internal_has_pluginflag() const;
  public:
  void clear_pluginflag();
  uint32_t pluginflag() const;
  void set_pluginflag(uint32_t value);
  private:
  uint32_t _internal_pluginflag() const;
  void _internal_set_pluginflag(uint32_t value);
  public:

  // optional uint32 verifyFlag = 17;
  bool has_verifyflag() const;
  private:
  bool _internal_has_verifyflag() const;
  public:
  void clear_verifyflag();
  uint32_t verifyflag() const;
  void set_verifyflag(uint32_t value);
  private:
  uint32_t _internal_verifyflag() const;
  void _internal_set_verifyflag(uint32_t value);
  public:

  // optional int32 point = 19;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  int32_t point() const;
  void set_point(int32_t value);
  private:
  int32_t _internal_point() const;
  void _internal_set_point(int32_t value);
  public:

  // optional int32 experience = 20;
  bool has_experience() const;
  private:
  bool _internal_has_experience() const;
  public:
  void clear_experience();
  int32_t experience() const;
  void set_experience(int32_t value);
  private:
  int32_t _internal_experience() const;
  void _internal_set_experience(int32_t value);
  public:

  // optional int32 level = 21;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // optional int32 levelLowExp = 22;
  bool has_levellowexp() const;
  private:
  bool _internal_has_levellowexp() const;
  public:
  void clear_levellowexp();
  int32_t levellowexp() const;
  void set_levellowexp(int32_t value);
  private:
  int32_t _internal_levellowexp() const;
  void _internal_set_levellowexp(int32_t value);
  public:

  // optional int32 levelHighExp = 23;
  bool has_levelhighexp() const;
  private:
  bool _internal_has_levelhighexp() const;
  public:
  void clear_levelhighexp();
  int32_t levelhighexp() const;
  void set_levelhighexp(int32_t value);
  private:
  int32_t _internal_levelhighexp() const;
  void _internal_set_levelhighexp(int32_t value);
  public:

  // optional uint32 pluginSwitch = 25;
  bool has_pluginswitch() const;
  private:
  bool _internal_has_pluginswitch() const;
  public:
  void clear_pluginswitch();
  uint32_t pluginswitch() const;
  void set_pluginswitch(uint32_t value);
  private:
  uint32_t _internal_pluginswitch() const;
  void _internal_set_pluginswitch(uint32_t value);
  public:

  // optional uint32 weiboFlag = 29;
  bool has_weiboflag() const;
  private:
  bool _internal_has_weiboflag() const;
  public:
  void clear_weiboflag();
  uint32_t weiboflag() const;
  void set_weiboflag(uint32_t value);
  private:
  uint32_t _internal_weiboflag() const;
  void _internal_set_weiboflag(uint32_t value);
  public:

  // optional uint32 faceBookFlag = 30;
  bool has_facebookflag() const;
  private:
  bool _internal_has_facebookflag() const;
  public:
  void clear_facebookflag();
  uint32_t facebookflag() const;
  void set_facebookflag(uint32_t value);
  private:
  uint32_t _internal_facebookflag() const;
  void _internal_set_facebookflag(uint32_t value);
  public:

  // optional uint64 fbuserId = 31;
  bool has_fbuserid() const;
  private:
  bool _internal_has_fbuserid() const;
  public:
  void clear_fbuserid();
  uint64_t fbuserid() const;
  void set_fbuserid(uint64_t value);
  private:
  uint64_t _internal_fbuserid() const;
  void _internal_set_fbuserid(uint64_t value);
  public:

  // optional int32 albumStyle = 33;
  bool has_albumstyle() const;
  private:
  bool _internal_has_albumstyle() const;
  public:
  void clear_albumstyle();
  int32_t albumstyle() const;
  void set_albumstyle(int32_t value);
  private:
  int32_t _internal_albumstyle() const;
  void _internal_set_albumstyle(int32_t value);
  public:

  // optional int32 albumFlag = 34;
  bool has_albumflag() const;
  private:
  bool _internal_has_albumflag() const;
  public:
  void clear_albumflag();
  int32_t albumflag() const;
  void set_albumflag(int32_t value);
  private:
  int32_t _internal_albumflag() const;
  void _internal_set_albumflag(int32_t value);
  public:

  // optional uint32 txnewsCategory = 36;
  bool has_txnewscategory() const;
  private:
  bool _internal_has_txnewscategory() const;
  public:
  void clear_txnewscategory();
  uint32_t txnewscategory() const;
  void set_txnewscategory(uint32_t value);
  private:
  uint32_t _internal_txnewscategory() const;
  void _internal_set_txnewscategory(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ModUserInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imgbuf_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr province_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifyinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weibo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weibonickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fbusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr albumbgimgid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fbtoken_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
    ::SKBuiltinString_t* username_;
    ::SKBuiltinString_t* nickname_;
    ::SKBuiltinString_t* bindemail_;
    ::SKBuiltinString_t* bindmobile_;
    ::DisturbSetting* disturbsetting_;
    ::GmailList* gmaillist_;
    uint32_t bitflag_;
    uint32_t binduin_;
    uint32_t status_;
    uint32_t imglen_;
    int32_t sex_;
    uint32_t personalcard_;
    uint32_t pluginflag_;
    uint32_t verifyflag_;
    int32_t point_;
    int32_t experience_;
    int32_t level_;
    int32_t levellowexp_;
    int32_t levelhighexp_;
    uint32_t pluginswitch_;
    uint32_t weiboflag_;
    uint32_t facebookflag_;
    uint64_t fbuserid_;
    int32_t albumstyle_;
    int32_t albumflag_;
    uint32_t txnewscategory_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfoExt final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:UserInfoExt) */ {
 public:
  inline UserInfoExt() : UserInfoExt(nullptr) {}
  ~UserInfoExt() override;
  explicit PROTOBUF_CONSTEXPR UserInfoExt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfoExt(const UserInfoExt& from);
  UserInfoExt(UserInfoExt&& from) noexcept
    : UserInfoExt() {
    *this = ::std::move(from);
  }

  inline UserInfoExt& operator=(const UserInfoExt& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfoExt& operator=(UserInfoExt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserInfoExt& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfoExt* internal_default_instance() {
    return reinterpret_cast<const UserInfoExt*>(
               &_UserInfoExt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UserInfoExt& a, UserInfoExt& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfoExt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfoExt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfoExt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfoExt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserInfoExt& from);
  void MergeFrom(const UserInfoExt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserInfoExt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserInfoExt";
  }
  protected:
  explicit UserInfoExt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMyBrandListFieldNumber = 2,
    kMsgPushSoundFieldNumber = 3,
    kVoipPushSoundFieldNumber = 4,
    kSafeMobileFieldNumber = 8,
    kBigHeadImgUrlFieldNumber = 9,
    kSmallHeadImgUrlFieldNumber = 10,
    kGoogleContactNameFieldNumber = 16,
    kIdcardNumFieldNumber = 17,
    kRealNameFieldNumber = 18,
    kRegCountryFieldNumber = 19,
    kBbppidFieldNumber = 20,
    kBbpinFieldNumber = 21,
    kBbmnickNameFieldNumber = 22,
    kKfinfoFieldNumber = 24,
    kSecurityDeviceIdFieldNumber = 26,
    kWeiDianInfoFieldNumber = 28,
    kF2FpushSoundFieldNumber = 31,
    kBindXmailFieldNumber = 37,
    kPatSuffixFieldNumber = 38,
    kTextStatusIdFieldNumber = 49,
    kTextStatusExtInfoFieldNumber = 51,
    kSaltFieldNumber = 52,
    kSnsUserInfoFieldNumber = 1,
    kExtXmlFieldNumber = 12,
    kSafeDeviceListFieldNumber = 13,
    kLinkedinContactItemFieldNumber = 23,
    kPatternLockInfoFieldNumber = 25,
    kXagreementInfoFieldNumber = 47,
    kRingBackSettingFieldNumber = 55,
    kGlobalRingBackSettingFieldNumber = 57,
    kBigChatRoomSizeFieldNumber = 5,
    kBigChatRoomQuotaFieldNumber = 6,
    kBigChatRoomInviteFieldNumber = 7,
    kMainAcctTypeFieldNumber = 11,
    kSafeDeviceFieldNumber = 14,
    kGrayscaleFlagFieldNumber = 15,
    kPayWalletTypeFieldNumber = 27,
    kWalletRegionFieldNumber = 29,
    kExtStatusFieldNumber = 30,
    kPaySettingFieldNumber = 34,
    kUserStatusFieldNumber = 32,
    kPatSuffixVersionFieldNumber = 39,
    kTeenagerModeFinderSettingFieldNumber = 44,
    kTeenagerModeBizAcctSettingFieldNumber = 45,
    kTeenagerModeMiniProgramSettingFieldNumber = 46,
    kSmcryptoFlagFieldNumber = 56,
    kFinderSettingFieldNumber = 53,
    kDiscoveryPageCtrlFlagFieldNumber = 59,
    kNewcomeMsgDefaultVoiceNumberFieldNumber = 58,
  };
  // optional string myBrandList = 2;
  bool has_mybrandlist() const;
  private:
  bool _internal_has_mybrandlist() const;
  public:
  void clear_mybrandlist();
  const std::string& mybrandlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mybrandlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mybrandlist();
  PROTOBUF_NODISCARD std::string* release_mybrandlist();
  void set_allocated_mybrandlist(std::string* mybrandlist);
  private:
  const std::string& _internal_mybrandlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mybrandlist(const std::string& value);
  std::string* _internal_mutable_mybrandlist();
  public:

  // optional string msgPushSound = 3;
  bool has_msgpushsound() const;
  private:
  bool _internal_has_msgpushsound() const;
  public:
  void clear_msgpushsound();
  const std::string& msgpushsound() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgpushsound(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgpushsound();
  PROTOBUF_NODISCARD std::string* release_msgpushsound();
  void set_allocated_msgpushsound(std::string* msgpushsound);
  private:
  const std::string& _internal_msgpushsound() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgpushsound(const std::string& value);
  std::string* _internal_mutable_msgpushsound();
  public:

  // optional string voipPushSound = 4;
  bool has_voippushsound() const;
  private:
  bool _internal_has_voippushsound() const;
  public:
  void clear_voippushsound();
  const std::string& voippushsound() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voippushsound(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voippushsound();
  PROTOBUF_NODISCARD std::string* release_voippushsound();
  void set_allocated_voippushsound(std::string* voippushsound);
  private:
  const std::string& _internal_voippushsound() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voippushsound(const std::string& value);
  std::string* _internal_mutable_voippushsound();
  public:

  // optional string safeMobile = 8;
  bool has_safemobile() const;
  private:
  bool _internal_has_safemobile() const;
  public:
  void clear_safemobile();
  const std::string& safemobile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_safemobile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_safemobile();
  PROTOBUF_NODISCARD std::string* release_safemobile();
  void set_allocated_safemobile(std::string* safemobile);
  private:
  const std::string& _internal_safemobile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_safemobile(const std::string& value);
  std::string* _internal_mutable_safemobile();
  public:

  // optional string bigHeadImgUrl = 9;
  bool has_bigheadimgurl() const;
  private:
  bool _internal_has_bigheadimgurl() const;
  public:
  void clear_bigheadimgurl();
  const std::string& bigheadimgurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bigheadimgurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bigheadimgurl();
  PROTOBUF_NODISCARD std::string* release_bigheadimgurl();
  void set_allocated_bigheadimgurl(std::string* bigheadimgurl);
  private:
  const std::string& _internal_bigheadimgurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bigheadimgurl(const std::string& value);
  std::string* _internal_mutable_bigheadimgurl();
  public:

  // optional string smallHeadImgUrl = 10;
  bool has_smallheadimgurl() const;
  private:
  bool _internal_has_smallheadimgurl() const;
  public:
  void clear_smallheadimgurl();
  const std::string& smallheadimgurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smallheadimgurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smallheadimgurl();
  PROTOBUF_NODISCARD std::string* release_smallheadimgurl();
  void set_allocated_smallheadimgurl(std::string* smallheadimgurl);
  private:
  const std::string& _internal_smallheadimgurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smallheadimgurl(const std::string& value);
  std::string* _internal_mutable_smallheadimgurl();
  public:

  // optional string googleContactName = 16;
  bool has_googlecontactname() const;
  private:
  bool _internal_has_googlecontactname() const;
  public:
  void clear_googlecontactname();
  const std::string& googlecontactname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_googlecontactname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_googlecontactname();
  PROTOBUF_NODISCARD std::string* release_googlecontactname();
  void set_allocated_googlecontactname(std::string* googlecontactname);
  private:
  const std::string& _internal_googlecontactname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_googlecontactname(const std::string& value);
  std::string* _internal_mutable_googlecontactname();
  public:

  // optional string idcardNum = 17;
  bool has_idcardnum() const;
  private:
  bool _internal_has_idcardnum() const;
  public:
  void clear_idcardnum();
  const std::string& idcardnum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idcardnum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idcardnum();
  PROTOBUF_NODISCARD std::string* release_idcardnum();
  void set_allocated_idcardnum(std::string* idcardnum);
  private:
  const std::string& _internal_idcardnum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idcardnum(const std::string& value);
  std::string* _internal_mutable_idcardnum();
  public:

  // optional string realName = 18;
  bool has_realname() const;
  private:
  bool _internal_has_realname() const;
  public:
  void clear_realname();
  const std::string& realname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realname();
  PROTOBUF_NODISCARD std::string* release_realname();
  void set_allocated_realname(std::string* realname);
  private:
  const std::string& _internal_realname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realname(const std::string& value);
  std::string* _internal_mutable_realname();
  public:

  // optional string regCountry = 19;
  bool has_regcountry() const;
  private:
  bool _internal_has_regcountry() const;
  public:
  void clear_regcountry();
  const std::string& regcountry() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regcountry(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regcountry();
  PROTOBUF_NODISCARD std::string* release_regcountry();
  void set_allocated_regcountry(std::string* regcountry);
  private:
  const std::string& _internal_regcountry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regcountry(const std::string& value);
  std::string* _internal_mutable_regcountry();
  public:

  // optional string bbppid = 20;
  bool has_bbppid() const;
  private:
  bool _internal_has_bbppid() const;
  public:
  void clear_bbppid();
  const std::string& bbppid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bbppid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bbppid();
  PROTOBUF_NODISCARD std::string* release_bbppid();
  void set_allocated_bbppid(std::string* bbppid);
  private:
  const std::string& _internal_bbppid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bbppid(const std::string& value);
  std::string* _internal_mutable_bbppid();
  public:

  // optional string bbpin = 21;
  bool has_bbpin() const;
  private:
  bool _internal_has_bbpin() const;
  public:
  void clear_bbpin();
  const std::string& bbpin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bbpin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bbpin();
  PROTOBUF_NODISCARD std::string* release_bbpin();
  void set_allocated_bbpin(std::string* bbpin);
  private:
  const std::string& _internal_bbpin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bbpin(const std::string& value);
  std::string* _internal_mutable_bbpin();
  public:

  // optional string bbmnickName = 22;
  bool has_bbmnickname() const;
  private:
  bool _internal_has_bbmnickname() const;
  public:
  void clear_bbmnickname();
  const std::string& bbmnickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bbmnickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bbmnickname();
  PROTOBUF_NODISCARD std::string* release_bbmnickname();
  void set_allocated_bbmnickname(std::string* bbmnickname);
  private:
  const std::string& _internal_bbmnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bbmnickname(const std::string& value);
  std::string* _internal_mutable_bbmnickname();
  public:

  // optional string kfinfo = 24;
  bool has_kfinfo() const;
  private:
  bool _internal_has_kfinfo() const;
  public:
  void clear_kfinfo();
  const std::string& kfinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kfinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kfinfo();
  PROTOBUF_NODISCARD std::string* release_kfinfo();
  void set_allocated_kfinfo(std::string* kfinfo);
  private:
  const std::string& _internal_kfinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kfinfo(const std::string& value);
  std::string* _internal_mutable_kfinfo();
  public:

  // optional string securityDeviceId = 26;
  bool has_securitydeviceid() const;
  private:
  bool _internal_has_securitydeviceid() const;
  public:
  void clear_securitydeviceid();
  const std::string& securitydeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securitydeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securitydeviceid();
  PROTOBUF_NODISCARD std::string* release_securitydeviceid();
  void set_allocated_securitydeviceid(std::string* securitydeviceid);
  private:
  const std::string& _internal_securitydeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securitydeviceid(const std::string& value);
  std::string* _internal_mutable_securitydeviceid();
  public:

  // optional string weiDianInfo = 28;
  bool has_weidianinfo() const;
  private:
  bool _internal_has_weidianinfo() const;
  public:
  void clear_weidianinfo();
  const std::string& weidianinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weidianinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weidianinfo();
  PROTOBUF_NODISCARD std::string* release_weidianinfo();
  void set_allocated_weidianinfo(std::string* weidianinfo);
  private:
  const std::string& _internal_weidianinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weidianinfo(const std::string& value);
  std::string* _internal_mutable_weidianinfo();
  public:

  // optional string f2FpushSound = 31;
  bool has_f2fpushsound() const;
  private:
  bool _internal_has_f2fpushsound() const;
  public:
  void clear_f2fpushsound();
  const std::string& f2fpushsound() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f2fpushsound(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f2fpushsound();
  PROTOBUF_NODISCARD std::string* release_f2fpushsound();
  void set_allocated_f2fpushsound(std::string* f2fpushsound);
  private:
  const std::string& _internal_f2fpushsound() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f2fpushsound(const std::string& value);
  std::string* _internal_mutable_f2fpushsound();
  public:

  // optional string bindXmail = 37;
  bool has_bindxmail() const;
  private:
  bool _internal_has_bindxmail() const;
  public:
  void clear_bindxmail();
  const std::string& bindxmail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bindxmail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bindxmail();
  PROTOBUF_NODISCARD std::string* release_bindxmail();
  void set_allocated_bindxmail(std::string* bindxmail);
  private:
  const std::string& _internal_bindxmail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bindxmail(const std::string& value);
  std::string* _internal_mutable_bindxmail();
  public:

  // optional string patSuffix = 38;
  bool has_patsuffix() const;
  private:
  bool _internal_has_patsuffix() const;
  public:
  void clear_patsuffix();
  const std::string& patsuffix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_patsuffix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_patsuffix();
  PROTOBUF_NODISCARD std::string* release_patsuffix();
  void set_allocated_patsuffix(std::string* patsuffix);
  private:
  const std::string& _internal_patsuffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_patsuffix(const std::string& value);
  std::string* _internal_mutable_patsuffix();
  public:

  // optional string textStatusId = 49;
  bool has_textstatusid() const;
  private:
  bool _internal_has_textstatusid() const;
  public:
  void clear_textstatusid();
  const std::string& textstatusid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_textstatusid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_textstatusid();
  PROTOBUF_NODISCARD std::string* release_textstatusid();
  void set_allocated_textstatusid(std::string* textstatusid);
  private:
  const std::string& _internal_textstatusid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_textstatusid(const std::string& value);
  std::string* _internal_mutable_textstatusid();
  public:

  // optional string textStatusExtInfo = 51;
  bool has_textstatusextinfo() const;
  private:
  bool _internal_has_textstatusextinfo() const;
  public:
  void clear_textstatusextinfo();
  const std::string& textstatusextinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_textstatusextinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_textstatusextinfo();
  PROTOBUF_NODISCARD std::string* release_textstatusextinfo();
  void set_allocated_textstatusextinfo(std::string* textstatusextinfo);
  private:
  const std::string& _internal_textstatusextinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_textstatusextinfo(const std::string& value);
  std::string* _internal_mutable_textstatusextinfo();
  public:

  // optional string salt = 52;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // required .SnsUserInfo snsUserInfo = 1;
  bool has_snsuserinfo() const;
  private:
  bool _internal_has_snsuserinfo() const;
  public:
  void clear_snsuserinfo();
  const ::SnsUserInfo& snsuserinfo() const;
  PROTOBUF_NODISCARD ::SnsUserInfo* release_snsuserinfo();
  ::SnsUserInfo* mutable_snsuserinfo();
  void set_allocated_snsuserinfo(::SnsUserInfo* snsuserinfo);
  private:
  const ::SnsUserInfo& _internal_snsuserinfo() const;
  ::SnsUserInfo* _internal_mutable_snsuserinfo();
  public:
  void unsafe_arena_set_allocated_snsuserinfo(
      ::SnsUserInfo* snsuserinfo);
  ::SnsUserInfo* unsafe_arena_release_snsuserinfo();

  // optional .SKBuiltinString_t extXml = 12;
  bool has_extxml() const;
  private:
  bool _internal_has_extxml() const;
  public:
  void clear_extxml();
  const ::SKBuiltinString_t& extxml() const;
  PROTOBUF_NODISCARD ::SKBuiltinString_t* release_extxml();
  ::SKBuiltinString_t* mutable_extxml();
  void set_allocated_extxml(::SKBuiltinString_t* extxml);
  private:
  const ::SKBuiltinString_t& _internal_extxml() const;
  ::SKBuiltinString_t* _internal_mutable_extxml();
  public:
  void unsafe_arena_set_allocated_extxml(
      ::SKBuiltinString_t* extxml);
  ::SKBuiltinString_t* unsafe_arena_release_extxml();

  // optional .SafeDeviceList safeDeviceList = 13;
  bool has_safedevicelist() const;
  private:
  bool _internal_has_safedevicelist() const;
  public:
  void clear_safedevicelist();
  const ::SafeDeviceList& safedevicelist() const;
  PROTOBUF_NODISCARD ::SafeDeviceList* release_safedevicelist();
  ::SafeDeviceList* mutable_safedevicelist();
  void set_allocated_safedevicelist(::SafeDeviceList* safedevicelist);
  private:
  const ::SafeDeviceList& _internal_safedevicelist() const;
  ::SafeDeviceList* _internal_mutable_safedevicelist();
  public:
  void unsafe_arena_set_allocated_safedevicelist(
      ::SafeDeviceList* safedevicelist);
  ::SafeDeviceList* unsafe_arena_release_safedevicelist();

  // optional .LinkedinContactItem linkedinContactItem = 23;
  bool has_linkedincontactitem() const;
  private:
  bool _internal_has_linkedincontactitem() const;
  public:
  void clear_linkedincontactitem();
  const ::LinkedinContactItem& linkedincontactitem() const;
  PROTOBUF_NODISCARD ::LinkedinContactItem* release_linkedincontactitem();
  ::LinkedinContactItem* mutable_linkedincontactitem();
  void set_allocated_linkedincontactitem(::LinkedinContactItem* linkedincontactitem);
  private:
  const ::LinkedinContactItem& _internal_linkedincontactitem() const;
  ::LinkedinContactItem* _internal_mutable_linkedincontactitem();
  public:
  void unsafe_arena_set_allocated_linkedincontactitem(
      ::LinkedinContactItem* linkedincontactitem);
  ::LinkedinContactItem* unsafe_arena_release_linkedincontactitem();

  // optional .PatternLockInfo patternLockInfo = 25;
  bool has_patternlockinfo() const;
  private:
  bool _internal_has_patternlockinfo() const;
  public:
  void clear_patternlockinfo();
  const ::PatternLockInfo& patternlockinfo() const;
  PROTOBUF_NODISCARD ::PatternLockInfo* release_patternlockinfo();
  ::PatternLockInfo* mutable_patternlockinfo();
  void set_allocated_patternlockinfo(::PatternLockInfo* patternlockinfo);
  private:
  const ::PatternLockInfo& _internal_patternlockinfo() const;
  ::PatternLockInfo* _internal_mutable_patternlockinfo();
  public:
  void unsafe_arena_set_allocated_patternlockinfo(
      ::PatternLockInfo* patternlockinfo);
  ::PatternLockInfo* unsafe_arena_release_patternlockinfo();

  // optional .XAgreementInfo xagreementInfo = 47;
  bool has_xagreementinfo() const;
  private:
  bool _internal_has_xagreementinfo() const;
  public:
  void clear_xagreementinfo();
  const ::XAgreementInfo& xagreementinfo() const;
  PROTOBUF_NODISCARD ::XAgreementInfo* release_xagreementinfo();
  ::XAgreementInfo* mutable_xagreementinfo();
  void set_allocated_xagreementinfo(::XAgreementInfo* xagreementinfo);
  private:
  const ::XAgreementInfo& _internal_xagreementinfo() const;
  ::XAgreementInfo* _internal_mutable_xagreementinfo();
  public:
  void unsafe_arena_set_allocated_xagreementinfo(
      ::XAgreementInfo* xagreementinfo);
  ::XAgreementInfo* unsafe_arena_release_xagreementinfo();

  // optional .RingBackSetting ringBackSetting = 55;
  bool has_ringbacksetting() const;
  private:
  bool _internal_has_ringbacksetting() const;
  public:
  void clear_ringbacksetting();
  const ::RingBackSetting& ringbacksetting() const;
  PROTOBUF_NODISCARD ::RingBackSetting* release_ringbacksetting();
  ::RingBackSetting* mutable_ringbacksetting();
  void set_allocated_ringbacksetting(::RingBackSetting* ringbacksetting);
  private:
  const ::RingBackSetting& _internal_ringbacksetting() const;
  ::RingBackSetting* _internal_mutable_ringbacksetting();
  public:
  void unsafe_arena_set_allocated_ringbacksetting(
      ::RingBackSetting* ringbacksetting);
  ::RingBackSetting* unsafe_arena_release_ringbacksetting();

  // optional .NewRingBackSetting globalRingBackSetting = 57;
  bool has_globalringbacksetting() const;
  private:
  bool _internal_has_globalringbacksetting() const;
  public:
  void clear_globalringbacksetting();
  const ::NewRingBackSetting& globalringbacksetting() const;
  PROTOBUF_NODISCARD ::NewRingBackSetting* release_globalringbacksetting();
  ::NewRingBackSetting* mutable_globalringbacksetting();
  void set_allocated_globalringbacksetting(::NewRingBackSetting* globalringbacksetting);
  private:
  const ::NewRingBackSetting& _internal_globalringbacksetting() const;
  ::NewRingBackSetting* _internal_mutable_globalringbacksetting();
  public:
  void unsafe_arena_set_allocated_globalringbacksetting(
      ::NewRingBackSetting* globalringbacksetting);
  ::NewRingBackSetting* unsafe_arena_release_globalringbacksetting();

  // optional uint32 bigChatRoomSize = 5;
  bool has_bigchatroomsize() const;
  private:
  bool _internal_has_bigchatroomsize() const;
  public:
  void clear_bigchatroomsize();
  uint32_t bigchatroomsize() const;
  void set_bigchatroomsize(uint32_t value);
  private:
  uint32_t _internal_bigchatroomsize() const;
  void _internal_set_bigchatroomsize(uint32_t value);
  public:

  // optional uint32 bigChatRoomQuota = 6;
  bool has_bigchatroomquota() const;
  private:
  bool _internal_has_bigchatroomquota() const;
  public:
  void clear_bigchatroomquota();
  uint32_t bigchatroomquota() const;
  void set_bigchatroomquota(uint32_t value);
  private:
  uint32_t _internal_bigchatroomquota() const;
  void _internal_set_bigchatroomquota(uint32_t value);
  public:

  // optional uint32 bigChatRoomInvite = 7;
  bool has_bigchatroominvite() const;
  private:
  bool _internal_has_bigchatroominvite() const;
  public:
  void clear_bigchatroominvite();
  uint32_t bigchatroominvite() const;
  void set_bigchatroominvite(uint32_t value);
  private:
  uint32_t _internal_bigchatroominvite() const;
  void _internal_set_bigchatroominvite(uint32_t value);
  public:

  // optional uint32 mainAcctType = 11;
  bool has_mainaccttype() const;
  private:
  bool _internal_has_mainaccttype() const;
  public:
  void clear_mainaccttype();
  uint32_t mainaccttype() const;
  void set_mainaccttype(uint32_t value);
  private:
  uint32_t _internal_mainaccttype() const;
  void _internal_set_mainaccttype(uint32_t value);
  public:

  // optional uint32 safeDevice = 14;
  bool has_safedevice() const;
  private:
  bool _internal_has_safedevice() const;
  public:
  void clear_safedevice();
  uint32_t safedevice() const;
  void set_safedevice(uint32_t value);
  private:
  uint32_t _internal_safedevice() const;
  void _internal_set_safedevice(uint32_t value);
  public:

  // optional uint32 grayscaleFlag = 15;
  bool has_grayscaleflag() const;
  private:
  bool _internal_has_grayscaleflag() const;
  public:
  void clear_grayscaleflag();
  uint32_t grayscaleflag() const;
  void set_grayscaleflag(uint32_t value);
  private:
  uint32_t _internal_grayscaleflag() const;
  void _internal_set_grayscaleflag(uint32_t value);
  public:

  // optional uint32 payWalletType = 27;
  bool has_paywallettype() const;
  private:
  bool _internal_has_paywallettype() const;
  public:
  void clear_paywallettype();
  uint32_t paywallettype() const;
  void set_paywallettype(uint32_t value);
  private:
  uint32_t _internal_paywallettype() const;
  void _internal_set_paywallettype(uint32_t value);
  public:

  // optional uint32 walletRegion = 29;
  bool has_walletregion() const;
  private:
  bool _internal_has_walletregion() const;
  public:
  void clear_walletregion();
  uint32_t walletregion() const;
  void set_walletregion(uint32_t value);
  private:
  uint32_t _internal_walletregion() const;
  void _internal_set_walletregion(uint32_t value);
  public:

  // optional uint64 extStatus = 30;
  bool has_extstatus() const;
  private:
  bool _internal_has_extstatus() const;
  public:
  void clear_extstatus();
  uint64_t extstatus() const;
  void set_extstatus(uint64_t value);
  private:
  uint64_t _internal_extstatus() const;
  void _internal_set_extstatus(uint64_t value);
  public:

  // optional uint64 paySetting = 34;
  bool has_paysetting() const;
  private:
  bool _internal_has_paysetting() const;
  public:
  void clear_paysetting();
  uint64_t paysetting() const;
  void set_paysetting(uint64_t value);
  private:
  uint64_t _internal_paysetting() const;
  void _internal_set_paysetting(uint64_t value);
  public:

  // optional uint32 userStatus = 32;
  bool has_userstatus() const;
  private:
  bool _internal_has_userstatus() const;
  public:
  void clear_userstatus();
  uint32_t userstatus() const;
  void set_userstatus(uint32_t value);
  private:
  uint32_t _internal_userstatus() const;
  void _internal_set_userstatus(uint32_t value);
  public:

  // optional uint32 patSuffixVersion = 39;
  bool has_patsuffixversion() const;
  private:
  bool _internal_has_patsuffixversion() const;
  public:
  void clear_patsuffixversion();
  uint32_t patsuffixversion() const;
  void set_patsuffixversion(uint32_t value);
  private:
  uint32_t _internal_patsuffixversion() const;
  void _internal_set_patsuffixversion(uint32_t value);
  public:

  // optional uint32 teenagerModeFinderSetting = 44;
  bool has_teenagermodefindersetting() const;
  private:
  bool _internal_has_teenagermodefindersetting() const;
  public:
  void clear_teenagermodefindersetting();
  uint32_t teenagermodefindersetting() const;
  void set_teenagermodefindersetting(uint32_t value);
  private:
  uint32_t _internal_teenagermodefindersetting() const;
  void _internal_set_teenagermodefindersetting(uint32_t value);
  public:

  // optional uint32 teenagerModeBizAcctSetting = 45;
  bool has_teenagermodebizacctsetting() const;
  private:
  bool _internal_has_teenagermodebizacctsetting() const;
  public:
  void clear_teenagermodebizacctsetting();
  uint32_t teenagermodebizacctsetting() const;
  void set_teenagermodebizacctsetting(uint32_t value);
  private:
  uint32_t _internal_teenagermodebizacctsetting() const;
  void _internal_set_teenagermodebizacctsetting(uint32_t value);
  public:

  // optional uint32 teenagerModeMiniProgramSetting = 46;
  bool has_teenagermodeminiprogramsetting() const;
  private:
  bool _internal_has_teenagermodeminiprogramsetting() const;
  public:
  void clear_teenagermodeminiprogramsetting();
  uint32_t teenagermodeminiprogramsetting() const;
  void set_teenagermodeminiprogramsetting(uint32_t value);
  private:
  uint32_t _internal_teenagermodeminiprogramsetting() const;
  void _internal_set_teenagermodeminiprogramsetting(uint32_t value);
  public:

  // optional uint32 smcryptoFlag = 56;
  bool has_smcryptoflag() const;
  private:
  bool _internal_has_smcryptoflag() const;
  public:
  void clear_smcryptoflag();
  uint32_t smcryptoflag() const;
  void set_smcryptoflag(uint32_t value);
  private:
  uint32_t _internal_smcryptoflag() const;
  void _internal_set_smcryptoflag(uint32_t value);
  public:

  // optional uint64 finderSetting = 53;
  bool has_findersetting() const;
  private:
  bool _internal_has_findersetting() const;
  public:
  void clear_findersetting();
  uint64_t findersetting() const;
  void set_findersetting(uint64_t value);
  private:
  uint64_t _internal_findersetting() const;
  void _internal_set_findersetting(uint64_t value);
  public:

  // optional uint64 discoveryPageCtrlFlag = 59;
  bool has_discoverypagectrlflag() const;
  private:
  bool _internal_has_discoverypagectrlflag() const;
  public:
  void clear_discoverypagectrlflag();
  uint64_t discoverypagectrlflag() const;
  void set_discoverypagectrlflag(uint64_t value);
  private:
  uint64_t _internal_discoverypagectrlflag() const;
  void _internal_set_discoverypagectrlflag(uint64_t value);
  public:

  // optional uint32 newcomeMsgDefaultVoiceNumber = 58;
  bool has_newcomemsgdefaultvoicenumber() const;
  private:
  bool _internal_has_newcomemsgdefaultvoicenumber() const;
  public:
  void clear_newcomemsgdefaultvoicenumber();
  uint32_t newcomemsgdefaultvoicenumber() const;
  void set_newcomemsgdefaultvoicenumber(uint32_t value);
  private:
  uint32_t _internal_newcomemsgdefaultvoicenumber() const;
  void _internal_set_newcomemsgdefaultvoicenumber(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserInfoExt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mybrandlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgpushsound_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voippushsound_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr safemobile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bigheadimgurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smallheadimgurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr googlecontactname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idcardnum_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regcountry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bbppid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bbpin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bbmnickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kfinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securitydeviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weidianinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f2fpushsound_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindxmail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr patsuffix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textstatusid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textstatusextinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::SnsUserInfo* snsuserinfo_;
    ::SKBuiltinString_t* extxml_;
    ::SafeDeviceList* safedevicelist_;
    ::LinkedinContactItem* linkedincontactitem_;
    ::PatternLockInfo* patternlockinfo_;
    ::XAgreementInfo* xagreementinfo_;
    ::RingBackSetting* ringbacksetting_;
    ::NewRingBackSetting* globalringbacksetting_;
    uint32_t bigchatroomsize_;
    uint32_t bigchatroomquota_;
    uint32_t bigchatroominvite_;
    uint32_t mainaccttype_;
    uint32_t safedevice_;
    uint32_t grayscaleflag_;
    uint32_t paywallettype_;
    uint32_t walletregion_;
    uint64_t extstatus_;
    uint64_t paysetting_;
    uint32_t userstatus_;
    uint32_t patsuffixversion_;
    uint32_t teenagermodefindersetting_;
    uint32_t teenagermodebizacctsetting_;
    uint32_t teenagermodeminiprogramsetting_;
    uint32_t smcryptoflag_;
    uint64_t findersetting_;
    uint64_t discoverypagectrlflag_;
    uint32_t newcomemsgdefaultvoicenumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// -------------------------------------------------------------------

class GetProfileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GetProfileResponse) */ {
 public:
  inline GetProfileResponse() : GetProfileResponse(nullptr) {}
  ~GetProfileResponse() override;
  explicit PROTOBUF_CONSTEXPR GetProfileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProfileResponse(const GetProfileResponse& from);
  GetProfileResponse(GetProfileResponse&& from) noexcept
    : GetProfileResponse() {
    *this = ::std::move(from);
  }

  inline GetProfileResponse& operator=(const GetProfileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProfileResponse& operator=(GetProfileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetProfileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProfileResponse* internal_default_instance() {
    return reinterpret_cast<const GetProfileResponse*>(
               &_GetProfileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetProfileResponse& a, GetProfileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProfileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProfileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProfileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProfileResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetProfileResponse& from);
  void MergeFrom(const GetProfileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetProfileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetProfileResponse";
  }
  protected:
  explicit GetProfileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseResponseFieldNumber = 1,
    kUserInfoFieldNumber = 2,
    kUserInfoExtFieldNumber = 3,
  };
  // required .BaseResponse baseResponse = 1;
  bool has_baseresponse() const;
  private:
  bool _internal_has_baseresponse() const;
  public:
  void clear_baseresponse();
  const ::BaseResponse& baseresponse() const;
  PROTOBUF_NODISCARD ::BaseResponse* release_baseresponse();
  ::BaseResponse* mutable_baseresponse();
  void set_allocated_baseresponse(::BaseResponse* baseresponse);
  private:
  const ::BaseResponse& _internal_baseresponse() const;
  ::BaseResponse* _internal_mutable_baseresponse();
  public:
  void unsafe_arena_set_allocated_baseresponse(
      ::BaseResponse* baseresponse);
  ::BaseResponse* unsafe_arena_release_baseresponse();

  // required .ModUserInfo userInfo = 2;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::ModUserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::ModUserInfo* release_userinfo();
  ::ModUserInfo* mutable_userinfo();
  void set_allocated_userinfo(::ModUserInfo* userinfo);
  private:
  const ::ModUserInfo& _internal_userinfo() const;
  ::ModUserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::ModUserInfo* userinfo);
  ::ModUserInfo* unsafe_arena_release_userinfo();

  // required .UserInfoExt userInfoExt = 3;
  bool has_userinfoext() const;
  private:
  bool _internal_has_userinfoext() const;
  public:
  void clear_userinfoext();
  const ::UserInfoExt& userinfoext() const;
  PROTOBUF_NODISCARD ::UserInfoExt* release_userinfoext();
  ::UserInfoExt* mutable_userinfoext();
  void set_allocated_userinfoext(::UserInfoExt* userinfoext);
  private:
  const ::UserInfoExt& _internal_userinfoext() const;
  ::UserInfoExt* _internal_mutable_userinfoext();
  public:
  void unsafe_arena_set_allocated_userinfoext(
      ::UserInfoExt* userinfoext);
  ::UserInfoExt* unsafe_arena_release_userinfoext();

  // @@protoc_insertion_point(class_scope:GetProfileResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::BaseResponse* baseresponse_;
    ::ModUserInfo* userinfo_;
    ::UserInfoExt* userinfoext_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserInfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GmailList

// required uint32 count = 1;
inline bool GmailList::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GmailList::has_count() const {
  return _internal_has_count();
}
inline void GmailList::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GmailList::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t GmailList::count() const {
  // @@protoc_insertion_point(field_get:GmailList.count)
  return _internal_count();
}
inline void GmailList::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.count_ = value;
}
inline void GmailList::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:GmailList.count)
}

// repeated .GmailInfo list = 2;
inline int GmailList::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GmailList::list_size() const {
  return _internal_list_size();
}
inline void GmailList::clear_list() {
  _impl_.list_.Clear();
}
inline ::GmailInfo* GmailList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GmailList.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GmailInfo >*
GmailList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GmailList.list)
  return &_impl_.list_;
}
inline const ::GmailInfo& GmailList::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::GmailInfo& GmailList::list(int index) const {
  // @@protoc_insertion_point(field_get:GmailList.list)
  return _internal_list(index);
}
inline ::GmailInfo* GmailList::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::GmailInfo* GmailList::add_list() {
  ::GmailInfo* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GmailList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GmailInfo >&
GmailList::list() const {
  // @@protoc_insertion_point(field_list:GmailList.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// MusicRingBackSetting

// optional uint32 sid = 1;
inline bool MusicRingBackSetting::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MusicRingBackSetting::has_sid() const {
  return _internal_has_sid();
}
inline void MusicRingBackSetting::clear_sid() {
  _impl_.sid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MusicRingBackSetting::_internal_sid() const {
  return _impl_.sid_;
}
inline uint32_t MusicRingBackSetting::sid() const {
  // @@protoc_insertion_point(field_get:MusicRingBackSetting.sid)
  return _internal_sid();
}
inline void MusicRingBackSetting::_internal_set_sid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_ = value;
}
inline void MusicRingBackSetting::set_sid(uint32_t value) {
  _internal_set_sid(value);
  // @@protoc_insertion_point(field_set:MusicRingBackSetting.sid)
}

// -------------------------------------------------------------------

// FinderRingBackSetting

// optional uint64 finderObjectId = 1;
inline bool FinderRingBackSetting::_internal_has_finderobjectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FinderRingBackSetting::has_finderobjectid() const {
  return _internal_has_finderobjectid();
}
inline void FinderRingBackSetting::clear_finderobjectid() {
  _impl_.finderobjectid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FinderRingBackSetting::_internal_finderobjectid() const {
  return _impl_.finderobjectid_;
}
inline uint64_t FinderRingBackSetting::finderobjectid() const {
  // @@protoc_insertion_point(field_get:FinderRingBackSetting.finderObjectId)
  return _internal_finderobjectid();
}
inline void FinderRingBackSetting::_internal_set_finderobjectid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.finderobjectid_ = value;
}
inline void FinderRingBackSetting::set_finderobjectid(uint64_t value) {
  _internal_set_finderobjectid(value);
  // @@protoc_insertion_point(field_set:FinderRingBackSetting.finderObjectId)
}

// optional string finderNonceId = 2;
inline bool FinderRingBackSetting::_internal_has_findernonceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FinderRingBackSetting::has_findernonceid() const {
  return _internal_has_findernonceid();
}
inline void FinderRingBackSetting::clear_findernonceid() {
  _impl_.findernonceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FinderRingBackSetting::findernonceid() const {
  // @@protoc_insertion_point(field_get:FinderRingBackSetting.finderNonceId)
  return _internal_findernonceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinderRingBackSetting::set_findernonceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.findernonceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FinderRingBackSetting.finderNonceId)
}
inline std::string* FinderRingBackSetting::mutable_findernonceid() {
  std::string* _s = _internal_mutable_findernonceid();
  // @@protoc_insertion_point(field_mutable:FinderRingBackSetting.finderNonceId)
  return _s;
}
inline const std::string& FinderRingBackSetting::_internal_findernonceid() const {
  return _impl_.findernonceid_.Get();
}
inline void FinderRingBackSetting::_internal_set_findernonceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.findernonceid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinderRingBackSetting::_internal_mutable_findernonceid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.findernonceid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinderRingBackSetting::release_findernonceid() {
  // @@protoc_insertion_point(field_release:FinderRingBackSetting.finderNonceId)
  if (!_internal_has_findernonceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.findernonceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.findernonceid_.IsDefault()) {
    _impl_.findernonceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FinderRingBackSetting::set_allocated_findernonceid(std::string* findernonceid) {
  if (findernonceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.findernonceid_.SetAllocated(findernonceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.findernonceid_.IsDefault()) {
    _impl_.findernonceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FinderRingBackSetting.finderNonceId)
}

// -------------------------------------------------------------------

// NewRingBackSetting

// optional uint32 type = 1;
inline bool NewRingBackSetting::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewRingBackSetting::has_type() const {
  return _internal_has_type();
}
inline void NewRingBackSetting::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t NewRingBackSetting::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t NewRingBackSetting::type() const {
  // @@protoc_insertion_point(field_get:NewRingBackSetting.type)
  return _internal_type();
}
inline void NewRingBackSetting::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void NewRingBackSetting::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:NewRingBackSetting.type)
}

// optional uint32 startTime = 2;
inline bool NewRingBackSetting::_internal_has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewRingBackSetting::has_starttime() const {
  return _internal_has_starttime();
}
inline void NewRingBackSetting::clear_starttime() {
  _impl_.starttime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t NewRingBackSetting::_internal_starttime() const {
  return _impl_.starttime_;
}
inline uint32_t NewRingBackSetting::starttime() const {
  // @@protoc_insertion_point(field_get:NewRingBackSetting.startTime)
  return _internal_starttime();
}
inline void NewRingBackSetting::_internal_set_starttime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.starttime_ = value;
}
inline void NewRingBackSetting::set_starttime(uint32_t value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:NewRingBackSetting.startTime)
}

// optional uint32 endTime = 3;
inline bool NewRingBackSetting::_internal_has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NewRingBackSetting::has_endtime() const {
  return _internal_has_endtime();
}
inline void NewRingBackSetting::clear_endtime() {
  _impl_.endtime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t NewRingBackSetting::_internal_endtime() const {
  return _impl_.endtime_;
}
inline uint32_t NewRingBackSetting::endtime() const {
  // @@protoc_insertion_point(field_get:NewRingBackSetting.endTime)
  return _internal_endtime();
}
inline void NewRingBackSetting::_internal_set_endtime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.endtime_ = value;
}
inline void NewRingBackSetting::set_endtime(uint32_t value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:NewRingBackSetting.endTime)
}

// optional .MusicRingBackSetting music = 4;
inline bool NewRingBackSetting::_internal_has_music() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.music_ != nullptr);
  return value;
}
inline bool NewRingBackSetting::has_music() const {
  return _internal_has_music();
}
inline void NewRingBackSetting::clear_music() {
  if (_impl_.music_ != nullptr) _impl_.music_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MusicRingBackSetting& NewRingBackSetting::_internal_music() const {
  const ::MusicRingBackSetting* p = _impl_.music_;
  return p != nullptr ? *p : reinterpret_cast<const ::MusicRingBackSetting&>(
      ::_MusicRingBackSetting_default_instance_);
}
inline const ::MusicRingBackSetting& NewRingBackSetting::music() const {
  // @@protoc_insertion_point(field_get:NewRingBackSetting.music)
  return _internal_music();
}
inline void NewRingBackSetting::unsafe_arena_set_allocated_music(
    ::MusicRingBackSetting* music) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.music_);
  }
  _impl_.music_ = music;
  if (music) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NewRingBackSetting.music)
}
inline ::MusicRingBackSetting* NewRingBackSetting::release_music() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MusicRingBackSetting* temp = _impl_.music_;
  _impl_.music_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MusicRingBackSetting* NewRingBackSetting::unsafe_arena_release_music() {
  // @@protoc_insertion_point(field_release:NewRingBackSetting.music)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MusicRingBackSetting* temp = _impl_.music_;
  _impl_.music_ = nullptr;
  return temp;
}
inline ::MusicRingBackSetting* NewRingBackSetting::_internal_mutable_music() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.music_ == nullptr) {
    auto* p = CreateMaybeMessage<::MusicRingBackSetting>(GetArenaForAllocation());
    _impl_.music_ = p;
  }
  return _impl_.music_;
}
inline ::MusicRingBackSetting* NewRingBackSetting::mutable_music() {
  ::MusicRingBackSetting* _msg = _internal_mutable_music();
  // @@protoc_insertion_point(field_mutable:NewRingBackSetting.music)
  return _msg;
}
inline void NewRingBackSetting::set_allocated_music(::MusicRingBackSetting* music) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.music_;
  }
  if (music) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(music);
    if (message_arena != submessage_arena) {
      music = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, music, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.music_ = music;
  // @@protoc_insertion_point(field_set_allocated:NewRingBackSetting.music)
}

// optional .FinderRingBackSetting finder = 5;
inline bool NewRingBackSetting::_internal_has_finder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finder_ != nullptr);
  return value;
}
inline bool NewRingBackSetting::has_finder() const {
  return _internal_has_finder();
}
inline void NewRingBackSetting::clear_finder() {
  if (_impl_.finder_ != nullptr) _impl_.finder_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::FinderRingBackSetting& NewRingBackSetting::_internal_finder() const {
  const ::FinderRingBackSetting* p = _impl_.finder_;
  return p != nullptr ? *p : reinterpret_cast<const ::FinderRingBackSetting&>(
      ::_FinderRingBackSetting_default_instance_);
}
inline const ::FinderRingBackSetting& NewRingBackSetting::finder() const {
  // @@protoc_insertion_point(field_get:NewRingBackSetting.finder)
  return _internal_finder();
}
inline void NewRingBackSetting::unsafe_arena_set_allocated_finder(
    ::FinderRingBackSetting* finder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finder_);
  }
  _impl_.finder_ = finder;
  if (finder) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NewRingBackSetting.finder)
}
inline ::FinderRingBackSetting* NewRingBackSetting::release_finder() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::FinderRingBackSetting* temp = _impl_.finder_;
  _impl_.finder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FinderRingBackSetting* NewRingBackSetting::unsafe_arena_release_finder() {
  // @@protoc_insertion_point(field_release:NewRingBackSetting.finder)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::FinderRingBackSetting* temp = _impl_.finder_;
  _impl_.finder_ = nullptr;
  return temp;
}
inline ::FinderRingBackSetting* NewRingBackSetting::_internal_mutable_finder() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.finder_ == nullptr) {
    auto* p = CreateMaybeMessage<::FinderRingBackSetting>(GetArenaForAllocation());
    _impl_.finder_ = p;
  }
  return _impl_.finder_;
}
inline ::FinderRingBackSetting* NewRingBackSetting::mutable_finder() {
  ::FinderRingBackSetting* _msg = _internal_mutable_finder();
  // @@protoc_insertion_point(field_mutable:NewRingBackSetting.finder)
  return _msg;
}
inline void NewRingBackSetting::set_allocated_finder(::FinderRingBackSetting* finder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.finder_;
  }
  if (finder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finder);
    if (message_arena != submessage_arena) {
      finder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finder, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.finder_ = finder;
  // @@protoc_insertion_point(field_set_allocated:NewRingBackSetting.finder)
}

// -------------------------------------------------------------------

// RingBackSetting

// required uint64 finderObjectId = 1;
inline bool RingBackSetting::_internal_has_finderobjectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RingBackSetting::has_finderobjectid() const {
  return _internal_has_finderobjectid();
}
inline void RingBackSetting::clear_finderobjectid() {
  _impl_.finderobjectid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RingBackSetting::_internal_finderobjectid() const {
  return _impl_.finderobjectid_;
}
inline uint64_t RingBackSetting::finderobjectid() const {
  // @@protoc_insertion_point(field_get:RingBackSetting.finderObjectId)
  return _internal_finderobjectid();
}
inline void RingBackSetting::_internal_set_finderobjectid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.finderobjectid_ = value;
}
inline void RingBackSetting::set_finderobjectid(uint64_t value) {
  _internal_set_finderobjectid(value);
  // @@protoc_insertion_point(field_set:RingBackSetting.finderObjectId)
}

// required string finderNonceId = 2;
inline bool RingBackSetting::_internal_has_findernonceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RingBackSetting::has_findernonceid() const {
  return _internal_has_findernonceid();
}
inline void RingBackSetting::clear_findernonceid() {
  _impl_.findernonceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RingBackSetting::findernonceid() const {
  // @@protoc_insertion_point(field_get:RingBackSetting.finderNonceId)
  return _internal_findernonceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingBackSetting::set_findernonceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.findernonceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RingBackSetting.finderNonceId)
}
inline std::string* RingBackSetting::mutable_findernonceid() {
  std::string* _s = _internal_mutable_findernonceid();
  // @@protoc_insertion_point(field_mutable:RingBackSetting.finderNonceId)
  return _s;
}
inline const std::string& RingBackSetting::_internal_findernonceid() const {
  return _impl_.findernonceid_.Get();
}
inline void RingBackSetting::_internal_set_findernonceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.findernonceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RingBackSetting::_internal_mutable_findernonceid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.findernonceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RingBackSetting::release_findernonceid() {
  // @@protoc_insertion_point(field_release:RingBackSetting.finderNonceId)
  if (!_internal_has_findernonceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.findernonceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.findernonceid_.IsDefault()) {
    _impl_.findernonceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RingBackSetting::set_allocated_findernonceid(std::string* findernonceid) {
  if (findernonceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.findernonceid_.SetAllocated(findernonceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.findernonceid_.IsDefault()) {
    _impl_.findernonceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RingBackSetting.finderNonceId)
}

// required uint32 startTs = 3;
inline bool RingBackSetting::_internal_has_startts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RingBackSetting::has_startts() const {
  return _internal_has_startts();
}
inline void RingBackSetting::clear_startts() {
  _impl_.startts_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RingBackSetting::_internal_startts() const {
  return _impl_.startts_;
}
inline uint32_t RingBackSetting::startts() const {
  // @@protoc_insertion_point(field_get:RingBackSetting.startTs)
  return _internal_startts();
}
inline void RingBackSetting::_internal_set_startts(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.startts_ = value;
}
inline void RingBackSetting::set_startts(uint32_t value) {
  _internal_set_startts(value);
  // @@protoc_insertion_point(field_set:RingBackSetting.startTs)
}

// required uint32 endTs = 4;
inline bool RingBackSetting::_internal_has_endts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RingBackSetting::has_endts() const {
  return _internal_has_endts();
}
inline void RingBackSetting::clear_endts() {
  _impl_.endts_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RingBackSetting::_internal_endts() const {
  return _impl_.endts_;
}
inline uint32_t RingBackSetting::endts() const {
  // @@protoc_insertion_point(field_get:RingBackSetting.endTs)
  return _internal_endts();
}
inline void RingBackSetting::_internal_set_endts(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endts_ = value;
}
inline void RingBackSetting::set_endts(uint32_t value) {
  _internal_set_endts(value);
  // @@protoc_insertion_point(field_set:RingBackSetting.endTs)
}

// -------------------------------------------------------------------

// XAgreementInfo

// optional uint64 funcsSwitch = 1;
inline bool XAgreementInfo::_internal_has_funcsswitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool XAgreementInfo::has_funcsswitch() const {
  return _internal_has_funcsswitch();
}
inline void XAgreementInfo::clear_funcsswitch() {
  _impl_.funcsswitch_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t XAgreementInfo::_internal_funcsswitch() const {
  return _impl_.funcsswitch_;
}
inline uint64_t XAgreementInfo::funcsswitch() const {
  // @@protoc_insertion_point(field_get:XAgreementInfo.funcsSwitch)
  return _internal_funcsswitch();
}
inline void XAgreementInfo::_internal_set_funcsswitch(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.funcsswitch_ = value;
}
inline void XAgreementInfo::set_funcsswitch(uint64_t value) {
  _internal_set_funcsswitch(value);
  // @@protoc_insertion_point(field_set:XAgreementInfo.funcsSwitch)
}

// optional uint64 funcsUserChoiceSwitch = 2;
inline bool XAgreementInfo::_internal_has_funcsuserchoiceswitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool XAgreementInfo::has_funcsuserchoiceswitch() const {
  return _internal_has_funcsuserchoiceswitch();
}
inline void XAgreementInfo::clear_funcsuserchoiceswitch() {
  _impl_.funcsuserchoiceswitch_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t XAgreementInfo::_internal_funcsuserchoiceswitch() const {
  return _impl_.funcsuserchoiceswitch_;
}
inline uint64_t XAgreementInfo::funcsuserchoiceswitch() const {
  // @@protoc_insertion_point(field_get:XAgreementInfo.funcsUserChoiceSwitch)
  return _internal_funcsuserchoiceswitch();
}
inline void XAgreementInfo::_internal_set_funcsuserchoiceswitch(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.funcsuserchoiceswitch_ = value;
}
inline void XAgreementInfo::set_funcsuserchoiceswitch(uint64_t value) {
  _internal_set_funcsuserchoiceswitch(value);
  // @@protoc_insertion_point(field_set:XAgreementInfo.funcsUserChoiceSwitch)
}

// -------------------------------------------------------------------

// LinkedinContactItem

// optional string linkedinName = 1;
inline bool LinkedinContactItem::_internal_has_linkedinname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkedinContactItem::has_linkedinname() const {
  return _internal_has_linkedinname();
}
inline void LinkedinContactItem::clear_linkedinname() {
  _impl_.linkedinname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkedinContactItem::linkedinname() const {
  // @@protoc_insertion_point(field_get:LinkedinContactItem.linkedinName)
  return _internal_linkedinname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkedinContactItem::set_linkedinname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.linkedinname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LinkedinContactItem.linkedinName)
}
inline std::string* LinkedinContactItem::mutable_linkedinname() {
  std::string* _s = _internal_mutable_linkedinname();
  // @@protoc_insertion_point(field_mutable:LinkedinContactItem.linkedinName)
  return _s;
}
inline const std::string& LinkedinContactItem::_internal_linkedinname() const {
  return _impl_.linkedinname_.Get();
}
inline void LinkedinContactItem::_internal_set_linkedinname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.linkedinname_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::_internal_mutable_linkedinname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.linkedinname_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::release_linkedinname() {
  // @@protoc_insertion_point(field_release:LinkedinContactItem.linkedinName)
  if (!_internal_has_linkedinname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.linkedinname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinname_.IsDefault()) {
    _impl_.linkedinname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LinkedinContactItem::set_allocated_linkedinname(std::string* linkedinname) {
  if (linkedinname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.linkedinname_.SetAllocated(linkedinname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinname_.IsDefault()) {
    _impl_.linkedinname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LinkedinContactItem.linkedinName)
}

// optional string linkedinMemberId = 2;
inline bool LinkedinContactItem::_internal_has_linkedinmemberid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinkedinContactItem::has_linkedinmemberid() const {
  return _internal_has_linkedinmemberid();
}
inline void LinkedinContactItem::clear_linkedinmemberid() {
  _impl_.linkedinmemberid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LinkedinContactItem::linkedinmemberid() const {
  // @@protoc_insertion_point(field_get:LinkedinContactItem.linkedinMemberId)
  return _internal_linkedinmemberid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkedinContactItem::set_linkedinmemberid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.linkedinmemberid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LinkedinContactItem.linkedinMemberId)
}
inline std::string* LinkedinContactItem::mutable_linkedinmemberid() {
  std::string* _s = _internal_mutable_linkedinmemberid();
  // @@protoc_insertion_point(field_mutable:LinkedinContactItem.linkedinMemberId)
  return _s;
}
inline const std::string& LinkedinContactItem::_internal_linkedinmemberid() const {
  return _impl_.linkedinmemberid_.Get();
}
inline void LinkedinContactItem::_internal_set_linkedinmemberid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.linkedinmemberid_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::_internal_mutable_linkedinmemberid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.linkedinmemberid_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::release_linkedinmemberid() {
  // @@protoc_insertion_point(field_release:LinkedinContactItem.linkedinMemberId)
  if (!_internal_has_linkedinmemberid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.linkedinmemberid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinmemberid_.IsDefault()) {
    _impl_.linkedinmemberid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LinkedinContactItem::set_allocated_linkedinmemberid(std::string* linkedinmemberid) {
  if (linkedinmemberid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.linkedinmemberid_.SetAllocated(linkedinmemberid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinmemberid_.IsDefault()) {
    _impl_.linkedinmemberid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LinkedinContactItem.linkedinMemberId)
}

// optional string linkedinPublicUrl = 3;
inline bool LinkedinContactItem::_internal_has_linkedinpublicurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LinkedinContactItem::has_linkedinpublicurl() const {
  return _internal_has_linkedinpublicurl();
}
inline void LinkedinContactItem::clear_linkedinpublicurl() {
  _impl_.linkedinpublicurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LinkedinContactItem::linkedinpublicurl() const {
  // @@protoc_insertion_point(field_get:LinkedinContactItem.linkedinPublicUrl)
  return _internal_linkedinpublicurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkedinContactItem::set_linkedinpublicurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.linkedinpublicurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LinkedinContactItem.linkedinPublicUrl)
}
inline std::string* LinkedinContactItem::mutable_linkedinpublicurl() {
  std::string* _s = _internal_mutable_linkedinpublicurl();
  // @@protoc_insertion_point(field_mutable:LinkedinContactItem.linkedinPublicUrl)
  return _s;
}
inline const std::string& LinkedinContactItem::_internal_linkedinpublicurl() const {
  return _impl_.linkedinpublicurl_.Get();
}
inline void LinkedinContactItem::_internal_set_linkedinpublicurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.linkedinpublicurl_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::_internal_mutable_linkedinpublicurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.linkedinpublicurl_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkedinContactItem::release_linkedinpublicurl() {
  // @@protoc_insertion_point(field_release:LinkedinContactItem.linkedinPublicUrl)
  if (!_internal_has_linkedinpublicurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.linkedinpublicurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinpublicurl_.IsDefault()) {
    _impl_.linkedinpublicurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LinkedinContactItem::set_allocated_linkedinpublicurl(std::string* linkedinpublicurl) {
  if (linkedinpublicurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linkedinpublicurl_.SetAllocated(linkedinpublicurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedinpublicurl_.IsDefault()) {
    _impl_.linkedinpublicurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LinkedinContactItem.linkedinPublicUrl)
}

// -------------------------------------------------------------------

// PatternLockInfo

// optional uint32 patternVersion = 1;
inline bool PatternLockInfo::_internal_has_patternversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PatternLockInfo::has_patternversion() const {
  return _internal_has_patternversion();
}
inline void PatternLockInfo::clear_patternversion() {
  _impl_.patternversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PatternLockInfo::_internal_patternversion() const {
  return _impl_.patternversion_;
}
inline uint32_t PatternLockInfo::patternversion() const {
  // @@protoc_insertion_point(field_get:PatternLockInfo.patternVersion)
  return _internal_patternversion();
}
inline void PatternLockInfo::_internal_set_patternversion(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.patternversion_ = value;
}
inline void PatternLockInfo::set_patternversion(uint32_t value) {
  _internal_set_patternversion(value);
  // @@protoc_insertion_point(field_set:PatternLockInfo.patternVersion)
}

// optional .SKBuiltinBuffer_t sign = 2;
inline bool PatternLockInfo::_internal_has_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sign_ != nullptr);
  return value;
}
inline bool PatternLockInfo::has_sign() const {
  return _internal_has_sign();
}
inline const ::SKBuiltinBuffer_t& PatternLockInfo::_internal_sign() const {
  const ::SKBuiltinBuffer_t* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinBuffer_t&>(
      ::_SKBuiltinBuffer_t_default_instance_);
}
inline const ::SKBuiltinBuffer_t& PatternLockInfo::sign() const {
  // @@protoc_insertion_point(field_get:PatternLockInfo.sign)
  return _internal_sign();
}
inline void PatternLockInfo::unsafe_arena_set_allocated_sign(
    ::SKBuiltinBuffer_t* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PatternLockInfo.sign)
}
inline ::SKBuiltinBuffer_t* PatternLockInfo::release_sign() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SKBuiltinBuffer_t* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinBuffer_t* PatternLockInfo::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:PatternLockInfo.sign)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SKBuiltinBuffer_t* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::SKBuiltinBuffer_t* PatternLockInfo::_internal_mutable_sign() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinBuffer_t>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::SKBuiltinBuffer_t* PatternLockInfo::mutable_sign() {
  ::SKBuiltinBuffer_t* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:PatternLockInfo.sign)
  return _msg;
}
inline void PatternLockInfo::set_allocated_sign(::SKBuiltinBuffer_t* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:PatternLockInfo.sign)
}

// optional uint32 lockStatus = 3;
inline bool PatternLockInfo::_internal_has_lockstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PatternLockInfo::has_lockstatus() const {
  return _internal_has_lockstatus();
}
inline void PatternLockInfo::clear_lockstatus() {
  _impl_.lockstatus_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PatternLockInfo::_internal_lockstatus() const {
  return _impl_.lockstatus_;
}
inline uint32_t PatternLockInfo::lockstatus() const {
  // @@protoc_insertion_point(field_get:PatternLockInfo.lockStatus)
  return _internal_lockstatus();
}
inline void PatternLockInfo::_internal_set_lockstatus(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lockstatus_ = value;
}
inline void PatternLockInfo::set_lockstatus(uint32_t value) {
  _internal_set_lockstatus(value);
  // @@protoc_insertion_point(field_set:PatternLockInfo.lockStatus)
}

// -------------------------------------------------------------------

// SafeDevice

// optional string name = 1;
inline bool SafeDevice::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SafeDevice::has_name() const {
  return _internal_has_name();
}
inline void SafeDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SafeDevice::name() const {
  // @@protoc_insertion_point(field_get:SafeDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SafeDevice::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SafeDevice.name)
}
inline std::string* SafeDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SafeDevice.name)
  return _s;
}
inline const std::string& SafeDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SafeDevice::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SafeDevice::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SafeDevice::release_name() {
  // @@protoc_insertion_point(field_release:SafeDevice.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SafeDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SafeDevice.name)
}

// optional string uuid = 2;
inline bool SafeDevice::_internal_has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SafeDevice::has_uuid() const {
  return _internal_has_uuid();
}
inline void SafeDevice::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SafeDevice::uuid() const {
  // @@protoc_insertion_point(field_get:SafeDevice.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SafeDevice::set_uuid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SafeDevice.uuid)
}
inline std::string* SafeDevice::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:SafeDevice.uuid)
  return _s;
}
inline const std::string& SafeDevice::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void SafeDevice::_internal_set_uuid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* SafeDevice::_internal_mutable_uuid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* SafeDevice::release_uuid() {
  // @@protoc_insertion_point(field_release:SafeDevice.uuid)
  if (!_internal_has_uuid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.uuid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SafeDevice::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SafeDevice.uuid)
}

// optional string deviceType = 3;
inline bool SafeDevice::_internal_has_devicetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SafeDevice::has_devicetype() const {
  return _internal_has_devicetype();
}
inline void SafeDevice::clear_devicetype() {
  _impl_.devicetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SafeDevice::devicetype() const {
  // @@protoc_insertion_point(field_get:SafeDevice.deviceType)
  return _internal_devicetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SafeDevice::set_devicetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.devicetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SafeDevice.deviceType)
}
inline std::string* SafeDevice::mutable_devicetype() {
  std::string* _s = _internal_mutable_devicetype();
  // @@protoc_insertion_point(field_mutable:SafeDevice.deviceType)
  return _s;
}
inline const std::string& SafeDevice::_internal_devicetype() const {
  return _impl_.devicetype_.Get();
}
inline void SafeDevice::_internal_set_devicetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.devicetype_.Set(value, GetArenaForAllocation());
}
inline std::string* SafeDevice::_internal_mutable_devicetype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.devicetype_.Mutable(GetArenaForAllocation());
}
inline std::string* SafeDevice::release_devicetype() {
  // @@protoc_insertion_point(field_release:SafeDevice.deviceType)
  if (!_internal_has_devicetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.devicetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicetype_.IsDefault()) {
    _impl_.devicetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SafeDevice::set_allocated_devicetype(std::string* devicetype) {
  if (devicetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.devicetype_.SetAllocated(devicetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicetype_.IsDefault()) {
    _impl_.devicetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SafeDevice.deviceType)
}

// required uint32 createTime = 4;
inline bool SafeDevice::_internal_has_createtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SafeDevice::has_createtime() const {
  return _internal_has_createtime();
}
inline void SafeDevice::clear_createtime() {
  _impl_.createtime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SafeDevice::_internal_createtime() const {
  return _impl_.createtime_;
}
inline uint32_t SafeDevice::createtime() const {
  // @@protoc_insertion_point(field_get:SafeDevice.createTime)
  return _internal_createtime();
}
inline void SafeDevice::_internal_set_createtime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.createtime_ = value;
}
inline void SafeDevice::set_createtime(uint32_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:SafeDevice.createTime)
}

// -------------------------------------------------------------------

// SafeDeviceList

// required uint32 count = 1;
inline bool SafeDeviceList::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SafeDeviceList::has_count() const {
  return _internal_has_count();
}
inline void SafeDeviceList::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SafeDeviceList::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t SafeDeviceList::count() const {
  // @@protoc_insertion_point(field_get:SafeDeviceList.count)
  return _internal_count();
}
inline void SafeDeviceList::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.count_ = value;
}
inline void SafeDeviceList::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SafeDeviceList.count)
}

// repeated .SafeDevice list = 2;
inline int SafeDeviceList::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int SafeDeviceList::list_size() const {
  return _internal_list_size();
}
inline void SafeDeviceList::clear_list() {
  _impl_.list_.Clear();
}
inline ::SafeDevice* SafeDeviceList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:SafeDeviceList.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SafeDevice >*
SafeDeviceList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:SafeDeviceList.list)
  return &_impl_.list_;
}
inline const ::SafeDevice& SafeDeviceList::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::SafeDevice& SafeDeviceList::list(int index) const {
  // @@protoc_insertion_point(field_get:SafeDeviceList.list)
  return _internal_list(index);
}
inline ::SafeDevice* SafeDeviceList::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::SafeDevice* SafeDeviceList::add_list() {
  ::SafeDevice* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:SafeDeviceList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SafeDevice >&
SafeDeviceList::list() const {
  // @@protoc_insertion_point(field_list:SafeDeviceList.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// SnsUserInfo

// required uint32 snsFlag = 1;
inline bool SnsUserInfo::_internal_has_snsflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SnsUserInfo::has_snsflag() const {
  return _internal_has_snsflag();
}
inline void SnsUserInfo::clear_snsflag() {
  _impl_.snsflag_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SnsUserInfo::_internal_snsflag() const {
  return _impl_.snsflag_;
}
inline uint32_t SnsUserInfo::snsflag() const {
  // @@protoc_insertion_point(field_get:SnsUserInfo.snsFlag)
  return _internal_snsflag();
}
inline void SnsUserInfo::_internal_set_snsflag(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.snsflag_ = value;
}
inline void SnsUserInfo::set_snsflag(uint32_t value) {
  _internal_set_snsflag(value);
  // @@protoc_insertion_point(field_set:SnsUserInfo.snsFlag)
}

// optional string snsBgimgId = 2;
inline bool SnsUserInfo::_internal_has_snsbgimgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SnsUserInfo::has_snsbgimgid() const {
  return _internal_has_snsbgimgid();
}
inline void SnsUserInfo::clear_snsbgimgid() {
  _impl_.snsbgimgid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnsUserInfo::snsbgimgid() const {
  // @@protoc_insertion_point(field_get:SnsUserInfo.snsBgimgId)
  return _internal_snsbgimgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnsUserInfo::set_snsbgimgid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.snsbgimgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SnsUserInfo.snsBgimgId)
}
inline std::string* SnsUserInfo::mutable_snsbgimgid() {
  std::string* _s = _internal_mutable_snsbgimgid();
  // @@protoc_insertion_point(field_mutable:SnsUserInfo.snsBgimgId)
  return _s;
}
inline const std::string& SnsUserInfo::_internal_snsbgimgid() const {
  return _impl_.snsbgimgid_.Get();
}
inline void SnsUserInfo::_internal_set_snsbgimgid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.snsbgimgid_.Set(value, GetArenaForAllocation());
}
inline std::string* SnsUserInfo::_internal_mutable_snsbgimgid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.snsbgimgid_.Mutable(GetArenaForAllocation());
}
inline std::string* SnsUserInfo::release_snsbgimgid() {
  // @@protoc_insertion_point(field_release:SnsUserInfo.snsBgimgId)
  if (!_internal_has_snsbgimgid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.snsbgimgid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snsbgimgid_.IsDefault()) {
    _impl_.snsbgimgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SnsUserInfo::set_allocated_snsbgimgid(std::string* snsbgimgid) {
  if (snsbgimgid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.snsbgimgid_.SetAllocated(snsbgimgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snsbgimgid_.IsDefault()) {
    _impl_.snsbgimgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SnsUserInfo.snsBgimgId)
}

// optional uint64 snsBgobjectId = 3;
inline bool SnsUserInfo::_internal_has_snsbgobjectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SnsUserInfo::has_snsbgobjectid() const {
  return _internal_has_snsbgobjectid();
}
inline void SnsUserInfo::clear_snsbgobjectid() {
  _impl_.snsbgobjectid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t SnsUserInfo::_internal_snsbgobjectid() const {
  return _impl_.snsbgobjectid_;
}
inline uint64_t SnsUserInfo::snsbgobjectid() const {
  // @@protoc_insertion_point(field_get:SnsUserInfo.snsBgobjectId)
  return _internal_snsbgobjectid();
}
inline void SnsUserInfo::_internal_set_snsbgobjectid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.snsbgobjectid_ = value;
}
inline void SnsUserInfo::set_snsbgobjectid(uint64_t value) {
  _internal_set_snsbgobjectid(value);
  // @@protoc_insertion_point(field_set:SnsUserInfo.snsBgobjectId)
}

// optional uint32 snsFlagEx = 4;
inline bool SnsUserInfo::_internal_has_snsflagex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SnsUserInfo::has_snsflagex() const {
  return _internal_has_snsflagex();
}
inline void SnsUserInfo::clear_snsflagex() {
  _impl_.snsflagex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SnsUserInfo::_internal_snsflagex() const {
  return _impl_.snsflagex_;
}
inline uint32_t SnsUserInfo::snsflagex() const {
  // @@protoc_insertion_point(field_get:SnsUserInfo.snsFlagEx)
  return _internal_snsflagex();
}
inline void SnsUserInfo::_internal_set_snsflagex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.snsflagex_ = value;
}
inline void SnsUserInfo::set_snsflagex(uint32_t value) {
  _internal_set_snsflagex(value);
  // @@protoc_insertion_point(field_set:SnsUserInfo.snsFlagEx)
}

// optional uint32 snsPrivacyRecent = 5;
inline bool SnsUserInfo::_internal_has_snsprivacyrecent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SnsUserInfo::has_snsprivacyrecent() const {
  return _internal_has_snsprivacyrecent();
}
inline void SnsUserInfo::clear_snsprivacyrecent() {
  _impl_.snsprivacyrecent_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SnsUserInfo::_internal_snsprivacyrecent() const {
  return _impl_.snsprivacyrecent_;
}
inline uint32_t SnsUserInfo::snsprivacyrecent() const {
  // @@protoc_insertion_point(field_get:SnsUserInfo.snsPrivacyRecent)
  return _internal_snsprivacyrecent();
}
inline void SnsUserInfo::_internal_set_snsprivacyrecent(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.snsprivacyrecent_ = value;
}
inline void SnsUserInfo::set_snsprivacyrecent(uint32_t value) {
  _internal_set_snsprivacyrecent(value);
  // @@protoc_insertion_point(field_set:SnsUserInfo.snsPrivacyRecent)
}

// -------------------------------------------------------------------

// GmailInfo

// optional string gmailAcct = 1;
inline bool GmailInfo::_internal_has_gmailacct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GmailInfo::has_gmailacct() const {
  return _internal_has_gmailacct();
}
inline void GmailInfo::clear_gmailacct() {
  _impl_.gmailacct_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GmailInfo::gmailacct() const {
  // @@protoc_insertion_point(field_get:GmailInfo.gmailAcct)
  return _internal_gmailacct();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GmailInfo::set_gmailacct(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gmailacct_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GmailInfo.gmailAcct)
}
inline std::string* GmailInfo::mutable_gmailacct() {
  std::string* _s = _internal_mutable_gmailacct();
  // @@protoc_insertion_point(field_mutable:GmailInfo.gmailAcct)
  return _s;
}
inline const std::string& GmailInfo::_internal_gmailacct() const {
  return _impl_.gmailacct_.Get();
}
inline void GmailInfo::_internal_set_gmailacct(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gmailacct_.Set(value, GetArenaForAllocation());
}
inline std::string* GmailInfo::_internal_mutable_gmailacct() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gmailacct_.Mutable(GetArenaForAllocation());
}
inline std::string* GmailInfo::release_gmailacct() {
  // @@protoc_insertion_point(field_release:GmailInfo.gmailAcct)
  if (!_internal_has_gmailacct()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gmailacct_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gmailacct_.IsDefault()) {
    _impl_.gmailacct_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GmailInfo::set_allocated_gmailacct(std::string* gmailacct) {
  if (gmailacct != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gmailacct_.SetAllocated(gmailacct, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gmailacct_.IsDefault()) {
    _impl_.gmailacct_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GmailInfo.gmailAcct)
}

// required uint32 gmailSwitch = 2;
inline bool GmailInfo::_internal_has_gmailswitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GmailInfo::has_gmailswitch() const {
  return _internal_has_gmailswitch();
}
inline void GmailInfo::clear_gmailswitch() {
  _impl_.gmailswitch_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GmailInfo::_internal_gmailswitch() const {
  return _impl_.gmailswitch_;
}
inline uint32_t GmailInfo::gmailswitch() const {
  // @@protoc_insertion_point(field_get:GmailInfo.gmailSwitch)
  return _internal_gmailswitch();
}
inline void GmailInfo::_internal_set_gmailswitch(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gmailswitch_ = value;
}
inline void GmailInfo::set_gmailswitch(uint32_t value) {
  _internal_set_gmailswitch(value);
  // @@protoc_insertion_point(field_set:GmailInfo.gmailSwitch)
}

// required uint32 gmailErrCode = 3;
inline bool GmailInfo::_internal_has_gmailerrcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GmailInfo::has_gmailerrcode() const {
  return _internal_has_gmailerrcode();
}
inline void GmailInfo::clear_gmailerrcode() {
  _impl_.gmailerrcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GmailInfo::_internal_gmailerrcode() const {
  return _impl_.gmailerrcode_;
}
inline uint32_t GmailInfo::gmailerrcode() const {
  // @@protoc_insertion_point(field_get:GmailInfo.gmailErrCode)
  return _internal_gmailerrcode();
}
inline void GmailInfo::_internal_set_gmailerrcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gmailerrcode_ = value;
}
inline void GmailInfo::set_gmailerrcode(uint32_t value) {
  _internal_set_gmailerrcode(value);
  // @@protoc_insertion_point(field_set:GmailInfo.gmailErrCode)
}

// -------------------------------------------------------------------

// DisturbTimeSpan

// required uint32 beginTime = 1;
inline bool DisturbTimeSpan::_internal_has_begintime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisturbTimeSpan::has_begintime() const {
  return _internal_has_begintime();
}
inline void DisturbTimeSpan::clear_begintime() {
  _impl_.begintime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DisturbTimeSpan::_internal_begintime() const {
  return _impl_.begintime_;
}
inline uint32_t DisturbTimeSpan::begintime() const {
  // @@protoc_insertion_point(field_get:DisturbTimeSpan.beginTime)
  return _internal_begintime();
}
inline void DisturbTimeSpan::_internal_set_begintime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.begintime_ = value;
}
inline void DisturbTimeSpan::set_begintime(uint32_t value) {
  _internal_set_begintime(value);
  // @@protoc_insertion_point(field_set:DisturbTimeSpan.beginTime)
}

// required uint32 endTime = 2;
inline bool DisturbTimeSpan::_internal_has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DisturbTimeSpan::has_endtime() const {
  return _internal_has_endtime();
}
inline void DisturbTimeSpan::clear_endtime() {
  _impl_.endtime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DisturbTimeSpan::_internal_endtime() const {
  return _impl_.endtime_;
}
inline uint32_t DisturbTimeSpan::endtime() const {
  // @@protoc_insertion_point(field_get:DisturbTimeSpan.endTime)
  return _internal_endtime();
}
inline void DisturbTimeSpan::_internal_set_endtime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.endtime_ = value;
}
inline void DisturbTimeSpan::set_endtime(uint32_t value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:DisturbTimeSpan.endTime)
}

// -------------------------------------------------------------------

// DisturbSetting

// required uint32 nightSetting = 1;
inline bool DisturbSetting::_internal_has_nightsetting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DisturbSetting::has_nightsetting() const {
  return _internal_has_nightsetting();
}
inline void DisturbSetting::clear_nightsetting() {
  _impl_.nightsetting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DisturbSetting::_internal_nightsetting() const {
  return _impl_.nightsetting_;
}
inline uint32_t DisturbSetting::nightsetting() const {
  // @@protoc_insertion_point(field_get:DisturbSetting.nightSetting)
  return _internal_nightsetting();
}
inline void DisturbSetting::_internal_set_nightsetting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nightsetting_ = value;
}
inline void DisturbSetting::set_nightsetting(uint32_t value) {
  _internal_set_nightsetting(value);
  // @@protoc_insertion_point(field_set:DisturbSetting.nightSetting)
}

// required .DisturbTimeSpan nightTime = 2;
inline bool DisturbSetting::_internal_has_nighttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nighttime_ != nullptr);
  return value;
}
inline bool DisturbSetting::has_nighttime() const {
  return _internal_has_nighttime();
}
inline void DisturbSetting::clear_nighttime() {
  if (_impl_.nighttime_ != nullptr) _impl_.nighttime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DisturbTimeSpan& DisturbSetting::_internal_nighttime() const {
  const ::DisturbTimeSpan* p = _impl_.nighttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::DisturbTimeSpan&>(
      ::_DisturbTimeSpan_default_instance_);
}
inline const ::DisturbTimeSpan& DisturbSetting::nighttime() const {
  // @@protoc_insertion_point(field_get:DisturbSetting.nightTime)
  return _internal_nighttime();
}
inline void DisturbSetting::unsafe_arena_set_allocated_nighttime(
    ::DisturbTimeSpan* nighttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nighttime_);
  }
  _impl_.nighttime_ = nighttime;
  if (nighttime) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DisturbSetting.nightTime)
}
inline ::DisturbTimeSpan* DisturbSetting::release_nighttime() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DisturbTimeSpan* temp = _impl_.nighttime_;
  _impl_.nighttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DisturbTimeSpan* DisturbSetting::unsafe_arena_release_nighttime() {
  // @@protoc_insertion_point(field_release:DisturbSetting.nightTime)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DisturbTimeSpan* temp = _impl_.nighttime_;
  _impl_.nighttime_ = nullptr;
  return temp;
}
inline ::DisturbTimeSpan* DisturbSetting::_internal_mutable_nighttime() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.nighttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::DisturbTimeSpan>(GetArenaForAllocation());
    _impl_.nighttime_ = p;
  }
  return _impl_.nighttime_;
}
inline ::DisturbTimeSpan* DisturbSetting::mutable_nighttime() {
  ::DisturbTimeSpan* _msg = _internal_mutable_nighttime();
  // @@protoc_insertion_point(field_mutable:DisturbSetting.nightTime)
  return _msg;
}
inline void DisturbSetting::set_allocated_nighttime(::DisturbTimeSpan* nighttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nighttime_;
  }
  if (nighttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nighttime);
    if (message_arena != submessage_arena) {
      nighttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nighttime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nighttime_ = nighttime;
  // @@protoc_insertion_point(field_set_allocated:DisturbSetting.nightTime)
}

// required uint32 allDaySetting = 3;
inline bool DisturbSetting::_internal_has_alldaysetting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DisturbSetting::has_alldaysetting() const {
  return _internal_has_alldaysetting();
}
inline void DisturbSetting::clear_alldaysetting() {
  _impl_.alldaysetting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DisturbSetting::_internal_alldaysetting() const {
  return _impl_.alldaysetting_;
}
inline uint32_t DisturbSetting::alldaysetting() const {
  // @@protoc_insertion_point(field_get:DisturbSetting.allDaySetting)
  return _internal_alldaysetting();
}
inline void DisturbSetting::_internal_set_alldaysetting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alldaysetting_ = value;
}
inline void DisturbSetting::set_alldaysetting(uint32_t value) {
  _internal_set_alldaysetting(value);
  // @@protoc_insertion_point(field_set:DisturbSetting.allDaySetting)
}

// required .DisturbTimeSpan allDayTime = 4;
inline bool DisturbSetting::_internal_has_alldaytime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alldaytime_ != nullptr);
  return value;
}
inline bool DisturbSetting::has_alldaytime() const {
  return _internal_has_alldaytime();
}
inline void DisturbSetting::clear_alldaytime() {
  if (_impl_.alldaytime_ != nullptr) _impl_.alldaytime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DisturbTimeSpan& DisturbSetting::_internal_alldaytime() const {
  const ::DisturbTimeSpan* p = _impl_.alldaytime_;
  return p != nullptr ? *p : reinterpret_cast<const ::DisturbTimeSpan&>(
      ::_DisturbTimeSpan_default_instance_);
}
inline const ::DisturbTimeSpan& DisturbSetting::alldaytime() const {
  // @@protoc_insertion_point(field_get:DisturbSetting.allDayTime)
  return _internal_alldaytime();
}
inline void DisturbSetting::unsafe_arena_set_allocated_alldaytime(
    ::DisturbTimeSpan* alldaytime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alldaytime_);
  }
  _impl_.alldaytime_ = alldaytime;
  if (alldaytime) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DisturbSetting.allDayTime)
}
inline ::DisturbTimeSpan* DisturbSetting::release_alldaytime() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DisturbTimeSpan* temp = _impl_.alldaytime_;
  _impl_.alldaytime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DisturbTimeSpan* DisturbSetting::unsafe_arena_release_alldaytime() {
  // @@protoc_insertion_point(field_release:DisturbSetting.allDayTime)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DisturbTimeSpan* temp = _impl_.alldaytime_;
  _impl_.alldaytime_ = nullptr;
  return temp;
}
inline ::DisturbTimeSpan* DisturbSetting::_internal_mutable_alldaytime() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.alldaytime_ == nullptr) {
    auto* p = CreateMaybeMessage<::DisturbTimeSpan>(GetArenaForAllocation());
    _impl_.alldaytime_ = p;
  }
  return _impl_.alldaytime_;
}
inline ::DisturbTimeSpan* DisturbSetting::mutable_alldaytime() {
  ::DisturbTimeSpan* _msg = _internal_mutable_alldaytime();
  // @@protoc_insertion_point(field_mutable:DisturbSetting.allDayTime)
  return _msg;
}
inline void DisturbSetting::set_allocated_alldaytime(::DisturbTimeSpan* alldaytime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.alldaytime_;
  }
  if (alldaytime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(alldaytime);
    if (message_arena != submessage_arena) {
      alldaytime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alldaytime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.alldaytime_ = alldaytime;
  // @@protoc_insertion_point(field_set_allocated:DisturbSetting.allDayTime)
}

// -------------------------------------------------------------------

// ModUserInfo

// required uint32 bitFlag = 1;
inline bool ModUserInfo::_internal_has_bitflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ModUserInfo::has_bitflag() const {
  return _internal_has_bitflag();
}
inline void ModUserInfo::clear_bitflag() {
  _impl_.bitflag_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t ModUserInfo::_internal_bitflag() const {
  return _impl_.bitflag_;
}
inline uint32_t ModUserInfo::bitflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.bitFlag)
  return _internal_bitflag();
}
inline void ModUserInfo::_internal_set_bitflag(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.bitflag_ = value;
}
inline void ModUserInfo::set_bitflag(uint32_t value) {
  _internal_set_bitflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.bitFlag)
}

// required .SKBuiltinString_t userName = 2;
inline bool ModUserInfo::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.username_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_username() const {
  return _internal_has_username();
}
inline const ::SKBuiltinString_t& ModUserInfo::_internal_username() const {
  const ::SKBuiltinString_t* p = _impl_.username_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinString_t&>(
      ::_SKBuiltinString_t_default_instance_);
}
inline const ::SKBuiltinString_t& ModUserInfo::username() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.userName)
  return _internal_username();
}
inline void ModUserInfo::unsafe_arena_set_allocated_username(
    ::SKBuiltinString_t* username) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.username_);
  }
  _impl_.username_ = username;
  if (username) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.userName)
}
inline ::SKBuiltinString_t* ModUserInfo::release_username() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::SKBuiltinString_t* temp = _impl_.username_;
  _impl_.username_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_release:ModUserInfo.userName)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::SKBuiltinString_t* temp = _impl_.username_;
  _impl_.username_ = nullptr;
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.username_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinString_t>(GetArenaForAllocation());
    _impl_.username_ = p;
  }
  return _impl_.username_;
}
inline ::SKBuiltinString_t* ModUserInfo::mutable_username() {
  ::SKBuiltinString_t* _msg = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.userName)
  return _msg;
}
inline void ModUserInfo::set_allocated_username(::SKBuiltinString_t* username) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.username_);
  }
  if (username) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(username));
    if (message_arena != submessage_arena) {
      username = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, username, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.username_ = username;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.userName)
}

// required .SKBuiltinString_t nickName = 3;
inline bool ModUserInfo::_internal_has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nickname_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_nickname() const {
  return _internal_has_nickname();
}
inline const ::SKBuiltinString_t& ModUserInfo::_internal_nickname() const {
  const ::SKBuiltinString_t* p = _impl_.nickname_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinString_t&>(
      ::_SKBuiltinString_t_default_instance_);
}
inline const ::SKBuiltinString_t& ModUserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.nickName)
  return _internal_nickname();
}
inline void ModUserInfo::unsafe_arena_set_allocated_nickname(
    ::SKBuiltinString_t* nickname) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nickname_);
  }
  _impl_.nickname_ = nickname;
  if (nickname) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.nickName)
}
inline ::SKBuiltinString_t* ModUserInfo::release_nickname() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::SKBuiltinString_t* temp = _impl_.nickname_;
  _impl_.nickname_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::unsafe_arena_release_nickname() {
  // @@protoc_insertion_point(field_release:ModUserInfo.nickName)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::SKBuiltinString_t* temp = _impl_.nickname_;
  _impl_.nickname_ = nullptr;
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::_internal_mutable_nickname() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.nickname_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinString_t>(GetArenaForAllocation());
    _impl_.nickname_ = p;
  }
  return _impl_.nickname_;
}
inline ::SKBuiltinString_t* ModUserInfo::mutable_nickname() {
  ::SKBuiltinString_t* _msg = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.nickName)
  return _msg;
}
inline void ModUserInfo::set_allocated_nickname(::SKBuiltinString_t* nickname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nickname_);
  }
  if (nickname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nickname));
    if (message_arena != submessage_arena) {
      nickname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nickname, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.nickname_ = nickname;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.nickName)
}

// required uint32 bindUin = 4;
inline bool ModUserInfo::_internal_has_binduin() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ModUserInfo::has_binduin() const {
  return _internal_has_binduin();
}
inline void ModUserInfo::clear_binduin() {
  _impl_.binduin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t ModUserInfo::_internal_binduin() const {
  return _impl_.binduin_;
}
inline uint32_t ModUserInfo::binduin() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.bindUin)
  return _internal_binduin();
}
inline void ModUserInfo::_internal_set_binduin(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.binduin_ = value;
}
inline void ModUserInfo::set_binduin(uint32_t value) {
  _internal_set_binduin(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.bindUin)
}

// required .SKBuiltinString_t bindEmail = 5;
inline bool ModUserInfo::_internal_has_bindemail() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bindemail_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_bindemail() const {
  return _internal_has_bindemail();
}
inline const ::SKBuiltinString_t& ModUserInfo::_internal_bindemail() const {
  const ::SKBuiltinString_t* p = _impl_.bindemail_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinString_t&>(
      ::_SKBuiltinString_t_default_instance_);
}
inline const ::SKBuiltinString_t& ModUserInfo::bindemail() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.bindEmail)
  return _internal_bindemail();
}
inline void ModUserInfo::unsafe_arena_set_allocated_bindemail(
    ::SKBuiltinString_t* bindemail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bindemail_);
  }
  _impl_.bindemail_ = bindemail;
  if (bindemail) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.bindEmail)
}
inline ::SKBuiltinString_t* ModUserInfo::release_bindemail() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::SKBuiltinString_t* temp = _impl_.bindemail_;
  _impl_.bindemail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::unsafe_arena_release_bindemail() {
  // @@protoc_insertion_point(field_release:ModUserInfo.bindEmail)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::SKBuiltinString_t* temp = _impl_.bindemail_;
  _impl_.bindemail_ = nullptr;
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::_internal_mutable_bindemail() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.bindemail_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinString_t>(GetArenaForAllocation());
    _impl_.bindemail_ = p;
  }
  return _impl_.bindemail_;
}
inline ::SKBuiltinString_t* ModUserInfo::mutable_bindemail() {
  ::SKBuiltinString_t* _msg = _internal_mutable_bindemail();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.bindEmail)
  return _msg;
}
inline void ModUserInfo::set_allocated_bindemail(::SKBuiltinString_t* bindemail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bindemail_);
  }
  if (bindemail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bindemail));
    if (message_arena != submessage_arena) {
      bindemail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bindemail, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.bindemail_ = bindemail;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.bindEmail)
}

// required .SKBuiltinString_t bindMobile = 6;
inline bool ModUserInfo::_internal_has_bindmobile() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bindmobile_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_bindmobile() const {
  return _internal_has_bindmobile();
}
inline const ::SKBuiltinString_t& ModUserInfo::_internal_bindmobile() const {
  const ::SKBuiltinString_t* p = _impl_.bindmobile_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinString_t&>(
      ::_SKBuiltinString_t_default_instance_);
}
inline const ::SKBuiltinString_t& ModUserInfo::bindmobile() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.bindMobile)
  return _internal_bindmobile();
}
inline void ModUserInfo::unsafe_arena_set_allocated_bindmobile(
    ::SKBuiltinString_t* bindmobile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bindmobile_);
  }
  _impl_.bindmobile_ = bindmobile;
  if (bindmobile) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.bindMobile)
}
inline ::SKBuiltinString_t* ModUserInfo::release_bindmobile() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::SKBuiltinString_t* temp = _impl_.bindmobile_;
  _impl_.bindmobile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::unsafe_arena_release_bindmobile() {
  // @@protoc_insertion_point(field_release:ModUserInfo.bindMobile)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::SKBuiltinString_t* temp = _impl_.bindmobile_;
  _impl_.bindmobile_ = nullptr;
  return temp;
}
inline ::SKBuiltinString_t* ModUserInfo::_internal_mutable_bindmobile() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.bindmobile_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinString_t>(GetArenaForAllocation());
    _impl_.bindmobile_ = p;
  }
  return _impl_.bindmobile_;
}
inline ::SKBuiltinString_t* ModUserInfo::mutable_bindmobile() {
  ::SKBuiltinString_t* _msg = _internal_mutable_bindmobile();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.bindMobile)
  return _msg;
}
inline void ModUserInfo::set_allocated_bindmobile(::SKBuiltinString_t* bindmobile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bindmobile_);
  }
  if (bindmobile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bindmobile));
    if (message_arena != submessage_arena) {
      bindmobile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bindmobile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.bindmobile_ = bindmobile;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.bindMobile)
}

// required uint32 status = 7;
inline bool ModUserInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ModUserInfo::has_status() const {
  return _internal_has_status();
}
inline void ModUserInfo::clear_status() {
  _impl_.status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t ModUserInfo::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t ModUserInfo::status() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.status)
  return _internal_status();
}
inline void ModUserInfo::_internal_set_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.status_ = value;
}
inline void ModUserInfo::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.status)
}

// required uint32 imgLen = 8;
inline bool ModUserInfo::_internal_has_imglen() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ModUserInfo::has_imglen() const {
  return _internal_has_imglen();
}
inline void ModUserInfo::clear_imglen() {
  _impl_.imglen_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t ModUserInfo::_internal_imglen() const {
  return _impl_.imglen_;
}
inline uint32_t ModUserInfo::imglen() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.imgLen)
  return _internal_imglen();
}
inline void ModUserInfo::_internal_set_imglen(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.imglen_ = value;
}
inline void ModUserInfo::set_imglen(uint32_t value) {
  _internal_set_imglen(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.imgLen)
}

// optional bytes imgBuf = 9;
inline bool ModUserInfo::_internal_has_imgbuf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModUserInfo::has_imgbuf() const {
  return _internal_has_imgbuf();
}
inline void ModUserInfo::clear_imgbuf() {
  _impl_.imgbuf_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModUserInfo::imgbuf() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.imgBuf)
  return _internal_imgbuf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_imgbuf(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.imgbuf_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.imgBuf)
}
inline std::string* ModUserInfo::mutable_imgbuf() {
  std::string* _s = _internal_mutable_imgbuf();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.imgBuf)
  return _s;
}
inline const std::string& ModUserInfo::_internal_imgbuf() const {
  return _impl_.imgbuf_.Get();
}
inline void ModUserInfo::_internal_set_imgbuf(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.imgbuf_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_imgbuf() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.imgbuf_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_imgbuf() {
  // @@protoc_insertion_point(field_release:ModUserInfo.imgBuf)
  if (!_internal_has_imgbuf()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.imgbuf_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imgbuf_.IsDefault()) {
    _impl_.imgbuf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_imgbuf(std::string* imgbuf) {
  if (imgbuf != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.imgbuf_.SetAllocated(imgbuf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imgbuf_.IsDefault()) {
    _impl_.imgbuf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.imgBuf)
}

// optional int32 sex = 10;
inline bool ModUserInfo::_internal_has_sex() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ModUserInfo::has_sex() const {
  return _internal_has_sex();
}
inline void ModUserInfo::clear_sex() {
  _impl_.sex_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t ModUserInfo::_internal_sex() const {
  return _impl_.sex_;
}
inline int32_t ModUserInfo::sex() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.sex)
  return _internal_sex();
}
inline void ModUserInfo::_internal_set_sex(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.sex_ = value;
}
inline void ModUserInfo::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.sex)
}

// optional string province = 11;
inline bool ModUserInfo::_internal_has_province() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModUserInfo::has_province() const {
  return _internal_has_province();
}
inline void ModUserInfo::clear_province() {
  _impl_.province_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModUserInfo::province() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.province)
  return _internal_province();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_province(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.province_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.province)
}
inline std::string* ModUserInfo::mutable_province() {
  std::string* _s = _internal_mutable_province();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.province)
  return _s;
}
inline const std::string& ModUserInfo::_internal_province() const {
  return _impl_.province_.Get();
}
inline void ModUserInfo::_internal_set_province(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.province_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_province() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.province_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_province() {
  // @@protoc_insertion_point(field_release:ModUserInfo.province)
  if (!_internal_has_province()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.province_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.province_.IsDefault()) {
    _impl_.province_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_province(std::string* province) {
  if (province != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.province_.SetAllocated(province, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.province_.IsDefault()) {
    _impl_.province_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.province)
}

// optional string city = 12;
inline bool ModUserInfo::_internal_has_city() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModUserInfo::has_city() const {
  return _internal_has_city();
}
inline void ModUserInfo::clear_city() {
  _impl_.city_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ModUserInfo::city() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_city(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.city_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.city)
}
inline std::string* ModUserInfo::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.city)
  return _s;
}
inline const std::string& ModUserInfo::_internal_city() const {
  return _impl_.city_.Get();
}
inline void ModUserInfo::_internal_set_city(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.city_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_city() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.city_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_city() {
  // @@protoc_insertion_point(field_release:ModUserInfo.city)
  if (!_internal_has_city()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.city_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.city_.IsDefault()) {
    _impl_.city_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.city_.SetAllocated(city, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.city_.IsDefault()) {
    _impl_.city_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.city)
}

// optional string signature = 13;
inline bool ModUserInfo::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModUserInfo::has_signature() const {
  return _internal_has_signature();
}
inline void ModUserInfo::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ModUserInfo::signature() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.signature_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.signature)
}
inline std::string* ModUserInfo::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.signature)
  return _s;
}
inline const std::string& ModUserInfo::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void ModUserInfo::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_signature() {
  // @@protoc_insertion_point(field_release:ModUserInfo.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.signature)
}

// optional uint32 personalCard = 14;
inline bool ModUserInfo::_internal_has_personalcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool ModUserInfo::has_personalcard() const {
  return _internal_has_personalcard();
}
inline void ModUserInfo::clear_personalcard() {
  _impl_.personalcard_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t ModUserInfo::_internal_personalcard() const {
  return _impl_.personalcard_;
}
inline uint32_t ModUserInfo::personalcard() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.personalCard)
  return _internal_personalcard();
}
inline void ModUserInfo::_internal_set_personalcard(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.personalcard_ = value;
}
inline void ModUserInfo::set_personalcard(uint32_t value) {
  _internal_set_personalcard(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.personalCard)
}

// optional .DisturbSetting disturbSetting = 15;
inline bool ModUserInfo::_internal_has_disturbsetting() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disturbsetting_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_disturbsetting() const {
  return _internal_has_disturbsetting();
}
inline void ModUserInfo::clear_disturbsetting() {
  if (_impl_.disturbsetting_ != nullptr) _impl_.disturbsetting_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::DisturbSetting& ModUserInfo::_internal_disturbsetting() const {
  const ::DisturbSetting* p = _impl_.disturbsetting_;
  return p != nullptr ? *p : reinterpret_cast<const ::DisturbSetting&>(
      ::_DisturbSetting_default_instance_);
}
inline const ::DisturbSetting& ModUserInfo::disturbsetting() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.disturbSetting)
  return _internal_disturbsetting();
}
inline void ModUserInfo::unsafe_arena_set_allocated_disturbsetting(
    ::DisturbSetting* disturbsetting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disturbsetting_);
  }
  _impl_.disturbsetting_ = disturbsetting;
  if (disturbsetting) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.disturbSetting)
}
inline ::DisturbSetting* ModUserInfo::release_disturbsetting() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::DisturbSetting* temp = _impl_.disturbsetting_;
  _impl_.disturbsetting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DisturbSetting* ModUserInfo::unsafe_arena_release_disturbsetting() {
  // @@protoc_insertion_point(field_release:ModUserInfo.disturbSetting)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::DisturbSetting* temp = _impl_.disturbsetting_;
  _impl_.disturbsetting_ = nullptr;
  return temp;
}
inline ::DisturbSetting* ModUserInfo::_internal_mutable_disturbsetting() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.disturbsetting_ == nullptr) {
    auto* p = CreateMaybeMessage<::DisturbSetting>(GetArenaForAllocation());
    _impl_.disturbsetting_ = p;
  }
  return _impl_.disturbsetting_;
}
inline ::DisturbSetting* ModUserInfo::mutable_disturbsetting() {
  ::DisturbSetting* _msg = _internal_mutable_disturbsetting();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.disturbSetting)
  return _msg;
}
inline void ModUserInfo::set_allocated_disturbsetting(::DisturbSetting* disturbsetting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disturbsetting_;
  }
  if (disturbsetting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disturbsetting);
    if (message_arena != submessage_arena) {
      disturbsetting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disturbsetting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.disturbsetting_ = disturbsetting;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.disturbSetting)
}

// optional uint32 pluginFlag = 16;
inline bool ModUserInfo::_internal_has_pluginflag() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_pluginflag() const {
  return _internal_has_pluginflag();
}
inline void ModUserInfo::clear_pluginflag() {
  _impl_.pluginflag_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t ModUserInfo::_internal_pluginflag() const {
  return _impl_.pluginflag_;
}
inline uint32_t ModUserInfo::pluginflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.pluginFlag)
  return _internal_pluginflag();
}
inline void ModUserInfo::_internal_set_pluginflag(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.pluginflag_ = value;
}
inline void ModUserInfo::set_pluginflag(uint32_t value) {
  _internal_set_pluginflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.pluginFlag)
}

// optional uint32 verifyFlag = 17;
inline bool ModUserInfo::_internal_has_verifyflag() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_verifyflag() const {
  return _internal_has_verifyflag();
}
inline void ModUserInfo::clear_verifyflag() {
  _impl_.verifyflag_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t ModUserInfo::_internal_verifyflag() const {
  return _impl_.verifyflag_;
}
inline uint32_t ModUserInfo::verifyflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.verifyFlag)
  return _internal_verifyflag();
}
inline void ModUserInfo::_internal_set_verifyflag(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.verifyflag_ = value;
}
inline void ModUserInfo::set_verifyflag(uint32_t value) {
  _internal_set_verifyflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.verifyFlag)
}

// optional string verifyInfo = 18;
inline bool ModUserInfo::_internal_has_verifyinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ModUserInfo::has_verifyinfo() const {
  return _internal_has_verifyinfo();
}
inline void ModUserInfo::clear_verifyinfo() {
  _impl_.verifyinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ModUserInfo::verifyinfo() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.verifyInfo)
  return _internal_verifyinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_verifyinfo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.verifyinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.verifyInfo)
}
inline std::string* ModUserInfo::mutable_verifyinfo() {
  std::string* _s = _internal_mutable_verifyinfo();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.verifyInfo)
  return _s;
}
inline const std::string& ModUserInfo::_internal_verifyinfo() const {
  return _impl_.verifyinfo_.Get();
}
inline void ModUserInfo::_internal_set_verifyinfo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.verifyinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_verifyinfo() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.verifyinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_verifyinfo() {
  // @@protoc_insertion_point(field_release:ModUserInfo.verifyInfo)
  if (!_internal_has_verifyinfo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.verifyinfo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifyinfo_.IsDefault()) {
    _impl_.verifyinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_verifyinfo(std::string* verifyinfo) {
  if (verifyinfo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.verifyinfo_.SetAllocated(verifyinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifyinfo_.IsDefault()) {
    _impl_.verifyinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.verifyInfo)
}

// optional int32 point = 19;
inline bool ModUserInfo::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_point() const {
  return _internal_has_point();
}
inline void ModUserInfo::clear_point() {
  _impl_.point_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline int32_t ModUserInfo::_internal_point() const {
  return _impl_.point_;
}
inline int32_t ModUserInfo::point() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.point)
  return _internal_point();
}
inline void ModUserInfo::_internal_set_point(int32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.point_ = value;
}
inline void ModUserInfo::set_point(int32_t value) {
  _internal_set_point(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.point)
}

// optional int32 experience = 20;
inline bool ModUserInfo::_internal_has_experience() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_experience() const {
  return _internal_has_experience();
}
inline void ModUserInfo::clear_experience() {
  _impl_.experience_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline int32_t ModUserInfo::_internal_experience() const {
  return _impl_.experience_;
}
inline int32_t ModUserInfo::experience() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.experience)
  return _internal_experience();
}
inline void ModUserInfo::_internal_set_experience(int32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.experience_ = value;
}
inline void ModUserInfo::set_experience(int32_t value) {
  _internal_set_experience(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.experience)
}

// optional int32 level = 21;
inline bool ModUserInfo::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_level() const {
  return _internal_has_level();
}
inline void ModUserInfo::clear_level() {
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline int32_t ModUserInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t ModUserInfo::level() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.level)
  return _internal_level();
}
inline void ModUserInfo::_internal_set_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.level_ = value;
}
inline void ModUserInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.level)
}

// optional int32 levelLowExp = 22;
inline bool ModUserInfo::_internal_has_levellowexp() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_levellowexp() const {
  return _internal_has_levellowexp();
}
inline void ModUserInfo::clear_levellowexp() {
  _impl_.levellowexp_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline int32_t ModUserInfo::_internal_levellowexp() const {
  return _impl_.levellowexp_;
}
inline int32_t ModUserInfo::levellowexp() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.levelLowExp)
  return _internal_levellowexp();
}
inline void ModUserInfo::_internal_set_levellowexp(int32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.levellowexp_ = value;
}
inline void ModUserInfo::set_levellowexp(int32_t value) {
  _internal_set_levellowexp(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.levelLowExp)
}

// optional int32 levelHighExp = 23;
inline bool ModUserInfo::_internal_has_levelhighexp() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_levelhighexp() const {
  return _internal_has_levelhighexp();
}
inline void ModUserInfo::clear_levelhighexp() {
  _impl_.levelhighexp_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline int32_t ModUserInfo::_internal_levelhighexp() const {
  return _impl_.levelhighexp_;
}
inline int32_t ModUserInfo::levelhighexp() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.levelHighExp)
  return _internal_levelhighexp();
}
inline void ModUserInfo::_internal_set_levelhighexp(int32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.levelhighexp_ = value;
}
inline void ModUserInfo::set_levelhighexp(int32_t value) {
  _internal_set_levelhighexp(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.levelHighExp)
}

// optional string weibo = 24;
inline bool ModUserInfo::_internal_has_weibo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ModUserInfo::has_weibo() const {
  return _internal_has_weibo();
}
inline void ModUserInfo::clear_weibo() {
  _impl_.weibo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ModUserInfo::weibo() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.weibo)
  return _internal_weibo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_weibo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.weibo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.weibo)
}
inline std::string* ModUserInfo::mutable_weibo() {
  std::string* _s = _internal_mutable_weibo();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.weibo)
  return _s;
}
inline const std::string& ModUserInfo::_internal_weibo() const {
  return _impl_.weibo_.Get();
}
inline void ModUserInfo::_internal_set_weibo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.weibo_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_weibo() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.weibo_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_weibo() {
  // @@protoc_insertion_point(field_release:ModUserInfo.weibo)
  if (!_internal_has_weibo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.weibo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weibo_.IsDefault()) {
    _impl_.weibo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_weibo(std::string* weibo) {
  if (weibo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.weibo_.SetAllocated(weibo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weibo_.IsDefault()) {
    _impl_.weibo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.weibo)
}

// optional uint32 pluginSwitch = 25;
inline bool ModUserInfo::_internal_has_pluginswitch() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool ModUserInfo::has_pluginswitch() const {
  return _internal_has_pluginswitch();
}
inline void ModUserInfo::clear_pluginswitch() {
  _impl_.pluginswitch_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline uint32_t ModUserInfo::_internal_pluginswitch() const {
  return _impl_.pluginswitch_;
}
inline uint32_t ModUserInfo::pluginswitch() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.pluginSwitch)
  return _internal_pluginswitch();
}
inline void ModUserInfo::_internal_set_pluginswitch(uint32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.pluginswitch_ = value;
}
inline void ModUserInfo::set_pluginswitch(uint32_t value) {
  _internal_set_pluginswitch(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.pluginSwitch)
}

// optional .GmailList gmailList = 26;
inline bool ModUserInfo::_internal_has_gmaillist() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gmaillist_ != nullptr);
  return value;
}
inline bool ModUserInfo::has_gmaillist() const {
  return _internal_has_gmaillist();
}
inline void ModUserInfo::clear_gmaillist() {
  if (_impl_.gmaillist_ != nullptr) _impl_.gmaillist_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::GmailList& ModUserInfo::_internal_gmaillist() const {
  const ::GmailList* p = _impl_.gmaillist_;
  return p != nullptr ? *p : reinterpret_cast<const ::GmailList&>(
      ::_GmailList_default_instance_);
}
inline const ::GmailList& ModUserInfo::gmaillist() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.gmailList)
  return _internal_gmaillist();
}
inline void ModUserInfo::unsafe_arena_set_allocated_gmaillist(
    ::GmailList* gmaillist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gmaillist_);
  }
  _impl_.gmaillist_ = gmaillist;
  if (gmaillist) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModUserInfo.gmailList)
}
inline ::GmailList* ModUserInfo::release_gmaillist() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::GmailList* temp = _impl_.gmaillist_;
  _impl_.gmaillist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GmailList* ModUserInfo::unsafe_arena_release_gmaillist() {
  // @@protoc_insertion_point(field_release:ModUserInfo.gmailList)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::GmailList* temp = _impl_.gmaillist_;
  _impl_.gmaillist_ = nullptr;
  return temp;
}
inline ::GmailList* ModUserInfo::_internal_mutable_gmaillist() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.gmaillist_ == nullptr) {
    auto* p = CreateMaybeMessage<::GmailList>(GetArenaForAllocation());
    _impl_.gmaillist_ = p;
  }
  return _impl_.gmaillist_;
}
inline ::GmailList* ModUserInfo::mutable_gmaillist() {
  ::GmailList* _msg = _internal_mutable_gmaillist();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.gmailList)
  return _msg;
}
inline void ModUserInfo::set_allocated_gmaillist(::GmailList* gmaillist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gmaillist_;
  }
  if (gmaillist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gmaillist);
    if (message_arena != submessage_arena) {
      gmaillist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gmaillist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.gmaillist_ = gmaillist;
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.gmailList)
}

// optional string alias = 27;
inline bool ModUserInfo::_internal_has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ModUserInfo::has_alias() const {
  return _internal_has_alias();
}
inline void ModUserInfo::clear_alias() {
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ModUserInfo::alias() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_alias(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.alias_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.alias)
}
inline std::string* ModUserInfo::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.alias)
  return _s;
}
inline const std::string& ModUserInfo::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void ModUserInfo::_internal_set_alias(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_alias() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_alias() {
  // @@protoc_insertion_point(field_release:ModUserInfo.alias)
  if (!_internal_has_alias()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.alias_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.alias)
}

// optional string weiboNickname = 28;
inline bool ModUserInfo::_internal_has_weibonickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ModUserInfo::has_weibonickname() const {
  return _internal_has_weibonickname();
}
inline void ModUserInfo::clear_weibonickname() {
  _impl_.weibonickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ModUserInfo::weibonickname() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.weiboNickname)
  return _internal_weibonickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_weibonickname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.weibonickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.weiboNickname)
}
inline std::string* ModUserInfo::mutable_weibonickname() {
  std::string* _s = _internal_mutable_weibonickname();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.weiboNickname)
  return _s;
}
inline const std::string& ModUserInfo::_internal_weibonickname() const {
  return _impl_.weibonickname_.Get();
}
inline void ModUserInfo::_internal_set_weibonickname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.weibonickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_weibonickname() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.weibonickname_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_weibonickname() {
  // @@protoc_insertion_point(field_release:ModUserInfo.weiboNickname)
  if (!_internal_has_weibonickname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.weibonickname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weibonickname_.IsDefault()) {
    _impl_.weibonickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_weibonickname(std::string* weibonickname) {
  if (weibonickname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.weibonickname_.SetAllocated(weibonickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weibonickname_.IsDefault()) {
    _impl_.weibonickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.weiboNickname)
}

// optional uint32 weiboFlag = 29;
inline bool ModUserInfo::_internal_has_weiboflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool ModUserInfo::has_weiboflag() const {
  return _internal_has_weiboflag();
}
inline void ModUserInfo::clear_weiboflag() {
  _impl_.weiboflag_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline uint32_t ModUserInfo::_internal_weiboflag() const {
  return _impl_.weiboflag_;
}
inline uint32_t ModUserInfo::weiboflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.weiboFlag)
  return _internal_weiboflag();
}
inline void ModUserInfo::_internal_set_weiboflag(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.weiboflag_ = value;
}
inline void ModUserInfo::set_weiboflag(uint32_t value) {
  _internal_set_weiboflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.weiboFlag)
}

// optional uint32 faceBookFlag = 30;
inline bool ModUserInfo::_internal_has_facebookflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool ModUserInfo::has_facebookflag() const {
  return _internal_has_facebookflag();
}
inline void ModUserInfo::clear_facebookflag() {
  _impl_.facebookflag_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t ModUserInfo::_internal_facebookflag() const {
  return _impl_.facebookflag_;
}
inline uint32_t ModUserInfo::facebookflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.faceBookFlag)
  return _internal_facebookflag();
}
inline void ModUserInfo::_internal_set_facebookflag(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.facebookflag_ = value;
}
inline void ModUserInfo::set_facebookflag(uint32_t value) {
  _internal_set_facebookflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.faceBookFlag)
}

// optional uint64 fbuserId = 31;
inline bool ModUserInfo::_internal_has_fbuserid() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool ModUserInfo::has_fbuserid() const {
  return _internal_has_fbuserid();
}
inline void ModUserInfo::clear_fbuserid() {
  _impl_.fbuserid_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint64_t ModUserInfo::_internal_fbuserid() const {
  return _impl_.fbuserid_;
}
inline uint64_t ModUserInfo::fbuserid() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.fbuserId)
  return _internal_fbuserid();
}
inline void ModUserInfo::_internal_set_fbuserid(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.fbuserid_ = value;
}
inline void ModUserInfo::set_fbuserid(uint64_t value) {
  _internal_set_fbuserid(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.fbuserId)
}

// optional string fbuserName = 32;
inline bool ModUserInfo::_internal_has_fbusername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ModUserInfo::has_fbusername() const {
  return _internal_has_fbusername();
}
inline void ModUserInfo::clear_fbusername() {
  _impl_.fbusername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ModUserInfo::fbusername() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.fbuserName)
  return _internal_fbusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_fbusername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.fbusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.fbuserName)
}
inline std::string* ModUserInfo::mutable_fbusername() {
  std::string* _s = _internal_mutable_fbusername();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.fbuserName)
  return _s;
}
inline const std::string& ModUserInfo::_internal_fbusername() const {
  return _impl_.fbusername_.Get();
}
inline void ModUserInfo::_internal_set_fbusername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.fbusername_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_fbusername() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.fbusername_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_fbusername() {
  // @@protoc_insertion_point(field_release:ModUserInfo.fbuserName)
  if (!_internal_has_fbusername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.fbusername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fbusername_.IsDefault()) {
    _impl_.fbusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_fbusername(std::string* fbusername) {
  if (fbusername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.fbusername_.SetAllocated(fbusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fbusername_.IsDefault()) {
    _impl_.fbusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.fbuserName)
}

// optional int32 albumStyle = 33;
inline bool ModUserInfo::_internal_has_albumstyle() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool ModUserInfo::has_albumstyle() const {
  return _internal_has_albumstyle();
}
inline void ModUserInfo::clear_albumstyle() {
  _impl_.albumstyle_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline int32_t ModUserInfo::_internal_albumstyle() const {
  return _impl_.albumstyle_;
}
inline int32_t ModUserInfo::albumstyle() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.albumStyle)
  return _internal_albumstyle();
}
inline void ModUserInfo::_internal_set_albumstyle(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.albumstyle_ = value;
}
inline void ModUserInfo::set_albumstyle(int32_t value) {
  _internal_set_albumstyle(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.albumStyle)
}

// optional int32 albumFlag = 34;
inline bool ModUserInfo::_internal_has_albumflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool ModUserInfo::has_albumflag() const {
  return _internal_has_albumflag();
}
inline void ModUserInfo::clear_albumflag() {
  _impl_.albumflag_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline int32_t ModUserInfo::_internal_albumflag() const {
  return _impl_.albumflag_;
}
inline int32_t ModUserInfo::albumflag() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.albumFlag)
  return _internal_albumflag();
}
inline void ModUserInfo::_internal_set_albumflag(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.albumflag_ = value;
}
inline void ModUserInfo::set_albumflag(int32_t value) {
  _internal_set_albumflag(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.albumFlag)
}

// optional string albumBgimgId = 35;
inline bool ModUserInfo::_internal_has_albumbgimgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ModUserInfo::has_albumbgimgid() const {
  return _internal_has_albumbgimgid();
}
inline void ModUserInfo::clear_albumbgimgid() {
  _impl_.albumbgimgid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ModUserInfo::albumbgimgid() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.albumBgimgId)
  return _internal_albumbgimgid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_albumbgimgid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.albumbgimgid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.albumBgimgId)
}
inline std::string* ModUserInfo::mutable_albumbgimgid() {
  std::string* _s = _internal_mutable_albumbgimgid();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.albumBgimgId)
  return _s;
}
inline const std::string& ModUserInfo::_internal_albumbgimgid() const {
  return _impl_.albumbgimgid_.Get();
}
inline void ModUserInfo::_internal_set_albumbgimgid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.albumbgimgid_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_albumbgimgid() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.albumbgimgid_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_albumbgimgid() {
  // @@protoc_insertion_point(field_release:ModUserInfo.albumBgimgId)
  if (!_internal_has_albumbgimgid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.albumbgimgid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumbgimgid_.IsDefault()) {
    _impl_.albumbgimgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_albumbgimgid(std::string* albumbgimgid) {
  if (albumbgimgid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.albumbgimgid_.SetAllocated(albumbgimgid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumbgimgid_.IsDefault()) {
    _impl_.albumbgimgid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.albumBgimgId)
}

// optional uint32 txnewsCategory = 36;
inline bool ModUserInfo::_internal_has_txnewscategory() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool ModUserInfo::has_txnewscategory() const {
  return _internal_has_txnewscategory();
}
inline void ModUserInfo::clear_txnewscategory() {
  _impl_.txnewscategory_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline uint32_t ModUserInfo::_internal_txnewscategory() const {
  return _impl_.txnewscategory_;
}
inline uint32_t ModUserInfo::txnewscategory() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.txnewsCategory)
  return _internal_txnewscategory();
}
inline void ModUserInfo::_internal_set_txnewscategory(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.txnewscategory_ = value;
}
inline void ModUserInfo::set_txnewscategory(uint32_t value) {
  _internal_set_txnewscategory(value);
  // @@protoc_insertion_point(field_set:ModUserInfo.txnewsCategory)
}

// optional string fbtoken = 37;
inline bool ModUserInfo::_internal_has_fbtoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ModUserInfo::has_fbtoken() const {
  return _internal_has_fbtoken();
}
inline void ModUserInfo::clear_fbtoken() {
  _impl_.fbtoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ModUserInfo::fbtoken() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.fbtoken)
  return _internal_fbtoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_fbtoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.fbtoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.fbtoken)
}
inline std::string* ModUserInfo::mutable_fbtoken() {
  std::string* _s = _internal_mutable_fbtoken();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.fbtoken)
  return _s;
}
inline const std::string& ModUserInfo::_internal_fbtoken() const {
  return _impl_.fbtoken_.Get();
}
inline void ModUserInfo::_internal_set_fbtoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.fbtoken_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_fbtoken() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.fbtoken_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_fbtoken() {
  // @@protoc_insertion_point(field_release:ModUserInfo.fbtoken)
  if (!_internal_has_fbtoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.fbtoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fbtoken_.IsDefault()) {
    _impl_.fbtoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_fbtoken(std::string* fbtoken) {
  if (fbtoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.fbtoken_.SetAllocated(fbtoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fbtoken_.IsDefault()) {
    _impl_.fbtoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.fbtoken)
}

// optional string country = 38;
inline bool ModUserInfo::_internal_has_country() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ModUserInfo::has_country() const {
  return _internal_has_country();
}
inline void ModUserInfo::clear_country() {
  _impl_.country_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ModUserInfo::country() const {
  // @@protoc_insertion_point(field_get:ModUserInfo.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModUserInfo::set_country(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModUserInfo.country)
}
inline std::string* ModUserInfo::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:ModUserInfo.country)
  return _s;
}
inline const std::string& ModUserInfo::_internal_country() const {
  return _impl_.country_.Get();
}
inline void ModUserInfo::_internal_set_country(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.country_.Set(value, GetArenaForAllocation());
}
inline std::string* ModUserInfo::_internal_mutable_country() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.country_.Mutable(GetArenaForAllocation());
}
inline std::string* ModUserInfo::release_country() {
  // @@protoc_insertion_point(field_release:ModUserInfo.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.country_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModUserInfo::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.country_.SetAllocated(country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModUserInfo.country)
}

// -------------------------------------------------------------------

// UserInfoExt

// required .SnsUserInfo snsUserInfo = 1;
inline bool UserInfoExt::_internal_has_snsuserinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.snsuserinfo_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_snsuserinfo() const {
  return _internal_has_snsuserinfo();
}
inline void UserInfoExt::clear_snsuserinfo() {
  if (_impl_.snsuserinfo_ != nullptr) _impl_.snsuserinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::SnsUserInfo& UserInfoExt::_internal_snsuserinfo() const {
  const ::SnsUserInfo* p = _impl_.snsuserinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::SnsUserInfo&>(
      ::_SnsUserInfo_default_instance_);
}
inline const ::SnsUserInfo& UserInfoExt::snsuserinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.snsUserInfo)
  return _internal_snsuserinfo();
}
inline void UserInfoExt::unsafe_arena_set_allocated_snsuserinfo(
    ::SnsUserInfo* snsuserinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snsuserinfo_);
  }
  _impl_.snsuserinfo_ = snsuserinfo;
  if (snsuserinfo) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.snsUserInfo)
}
inline ::SnsUserInfo* UserInfoExt::release_snsuserinfo() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::SnsUserInfo* temp = _impl_.snsuserinfo_;
  _impl_.snsuserinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SnsUserInfo* UserInfoExt::unsafe_arena_release_snsuserinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.snsUserInfo)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::SnsUserInfo* temp = _impl_.snsuserinfo_;
  _impl_.snsuserinfo_ = nullptr;
  return temp;
}
inline ::SnsUserInfo* UserInfoExt::_internal_mutable_snsuserinfo() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.snsuserinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::SnsUserInfo>(GetArenaForAllocation());
    _impl_.snsuserinfo_ = p;
  }
  return _impl_.snsuserinfo_;
}
inline ::SnsUserInfo* UserInfoExt::mutable_snsuserinfo() {
  ::SnsUserInfo* _msg = _internal_mutable_snsuserinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.snsUserInfo)
  return _msg;
}
inline void UserInfoExt::set_allocated_snsuserinfo(::SnsUserInfo* snsuserinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snsuserinfo_;
  }
  if (snsuserinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snsuserinfo);
    if (message_arena != submessage_arena) {
      snsuserinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snsuserinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.snsuserinfo_ = snsuserinfo;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.snsUserInfo)
}

// optional string myBrandList = 2;
inline bool UserInfoExt::_internal_has_mybrandlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfoExt::has_mybrandlist() const {
  return _internal_has_mybrandlist();
}
inline void UserInfoExt::clear_mybrandlist() {
  _impl_.mybrandlist_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfoExt::mybrandlist() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.myBrandList)
  return _internal_mybrandlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_mybrandlist(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mybrandlist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.myBrandList)
}
inline std::string* UserInfoExt::mutable_mybrandlist() {
  std::string* _s = _internal_mutable_mybrandlist();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.myBrandList)
  return _s;
}
inline const std::string& UserInfoExt::_internal_mybrandlist() const {
  return _impl_.mybrandlist_.Get();
}
inline void UserInfoExt::_internal_set_mybrandlist(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mybrandlist_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_mybrandlist() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mybrandlist_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_mybrandlist() {
  // @@protoc_insertion_point(field_release:UserInfoExt.myBrandList)
  if (!_internal_has_mybrandlist()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mybrandlist_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mybrandlist_.IsDefault()) {
    _impl_.mybrandlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_mybrandlist(std::string* mybrandlist) {
  if (mybrandlist != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mybrandlist_.SetAllocated(mybrandlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mybrandlist_.IsDefault()) {
    _impl_.mybrandlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.myBrandList)
}

// optional string msgPushSound = 3;
inline bool UserInfoExt::_internal_has_msgpushsound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfoExt::has_msgpushsound() const {
  return _internal_has_msgpushsound();
}
inline void UserInfoExt::clear_msgpushsound() {
  _impl_.msgpushsound_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfoExt::msgpushsound() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.msgPushSound)
  return _internal_msgpushsound();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_msgpushsound(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.msgpushsound_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.msgPushSound)
}
inline std::string* UserInfoExt::mutable_msgpushsound() {
  std::string* _s = _internal_mutable_msgpushsound();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.msgPushSound)
  return _s;
}
inline const std::string& UserInfoExt::_internal_msgpushsound() const {
  return _impl_.msgpushsound_.Get();
}
inline void UserInfoExt::_internal_set_msgpushsound(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msgpushsound_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_msgpushsound() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.msgpushsound_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_msgpushsound() {
  // @@protoc_insertion_point(field_release:UserInfoExt.msgPushSound)
  if (!_internal_has_msgpushsound()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.msgpushsound_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgpushsound_.IsDefault()) {
    _impl_.msgpushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_msgpushsound(std::string* msgpushsound) {
  if (msgpushsound != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.msgpushsound_.SetAllocated(msgpushsound, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgpushsound_.IsDefault()) {
    _impl_.msgpushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.msgPushSound)
}

// optional string voipPushSound = 4;
inline bool UserInfoExt::_internal_has_voippushsound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfoExt::has_voippushsound() const {
  return _internal_has_voippushsound();
}
inline void UserInfoExt::clear_voippushsound() {
  _impl_.voippushsound_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfoExt::voippushsound() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.voipPushSound)
  return _internal_voippushsound();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_voippushsound(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.voippushsound_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.voipPushSound)
}
inline std::string* UserInfoExt::mutable_voippushsound() {
  std::string* _s = _internal_mutable_voippushsound();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.voipPushSound)
  return _s;
}
inline const std::string& UserInfoExt::_internal_voippushsound() const {
  return _impl_.voippushsound_.Get();
}
inline void UserInfoExt::_internal_set_voippushsound(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.voippushsound_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_voippushsound() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.voippushsound_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_voippushsound() {
  // @@protoc_insertion_point(field_release:UserInfoExt.voipPushSound)
  if (!_internal_has_voippushsound()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.voippushsound_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voippushsound_.IsDefault()) {
    _impl_.voippushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_voippushsound(std::string* voippushsound) {
  if (voippushsound != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.voippushsound_.SetAllocated(voippushsound, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voippushsound_.IsDefault()) {
    _impl_.voippushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.voipPushSound)
}

// optional uint32 bigChatRoomSize = 5;
inline bool UserInfoExt::_internal_has_bigchatroomsize() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool UserInfoExt::has_bigchatroomsize() const {
  return _internal_has_bigchatroomsize();
}
inline void UserInfoExt::clear_bigchatroomsize() {
  _impl_.bigchatroomsize_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline uint32_t UserInfoExt::_internal_bigchatroomsize() const {
  return _impl_.bigchatroomsize_;
}
inline uint32_t UserInfoExt::bigchatroomsize() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bigChatRoomSize)
  return _internal_bigchatroomsize();
}
inline void UserInfoExt::_internal_set_bigchatroomsize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.bigchatroomsize_ = value;
}
inline void UserInfoExt::set_bigchatroomsize(uint32_t value) {
  _internal_set_bigchatroomsize(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.bigChatRoomSize)
}

// optional uint32 bigChatRoomQuota = 6;
inline bool UserInfoExt::_internal_has_bigchatroomquota() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool UserInfoExt::has_bigchatroomquota() const {
  return _internal_has_bigchatroomquota();
}
inline void UserInfoExt::clear_bigchatroomquota() {
  _impl_.bigchatroomquota_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline uint32_t UserInfoExt::_internal_bigchatroomquota() const {
  return _impl_.bigchatroomquota_;
}
inline uint32_t UserInfoExt::bigchatroomquota() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bigChatRoomQuota)
  return _internal_bigchatroomquota();
}
inline void UserInfoExt::_internal_set_bigchatroomquota(uint32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.bigchatroomquota_ = value;
}
inline void UserInfoExt::set_bigchatroomquota(uint32_t value) {
  _internal_set_bigchatroomquota(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.bigChatRoomQuota)
}

// optional uint32 bigChatRoomInvite = 7;
inline bool UserInfoExt::_internal_has_bigchatroominvite() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfoExt::has_bigchatroominvite() const {
  return _internal_has_bigchatroominvite();
}
inline void UserInfoExt::clear_bigchatroominvite() {
  _impl_.bigchatroominvite_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline uint32_t UserInfoExt::_internal_bigchatroominvite() const {
  return _impl_.bigchatroominvite_;
}
inline uint32_t UserInfoExt::bigchatroominvite() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bigChatRoomInvite)
  return _internal_bigchatroominvite();
}
inline void UserInfoExt::_internal_set_bigchatroominvite(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.bigchatroominvite_ = value;
}
inline void UserInfoExt::set_bigchatroominvite(uint32_t value) {
  _internal_set_bigchatroominvite(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.bigChatRoomInvite)
}

// optional string safeMobile = 8;
inline bool UserInfoExt::_internal_has_safemobile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfoExt::has_safemobile() const {
  return _internal_has_safemobile();
}
inline void UserInfoExt::clear_safemobile() {
  _impl_.safemobile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserInfoExt::safemobile() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.safeMobile)
  return _internal_safemobile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_safemobile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.safemobile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.safeMobile)
}
inline std::string* UserInfoExt::mutable_safemobile() {
  std::string* _s = _internal_mutable_safemobile();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.safeMobile)
  return _s;
}
inline const std::string& UserInfoExt::_internal_safemobile() const {
  return _impl_.safemobile_.Get();
}
inline void UserInfoExt::_internal_set_safemobile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.safemobile_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_safemobile() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.safemobile_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_safemobile() {
  // @@protoc_insertion_point(field_release:UserInfoExt.safeMobile)
  if (!_internal_has_safemobile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.safemobile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.safemobile_.IsDefault()) {
    _impl_.safemobile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_safemobile(std::string* safemobile) {
  if (safemobile != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.safemobile_.SetAllocated(safemobile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.safemobile_.IsDefault()) {
    _impl_.safemobile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.safeMobile)
}

// optional string bigHeadImgUrl = 9;
inline bool UserInfoExt::_internal_has_bigheadimgurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfoExt::has_bigheadimgurl() const {
  return _internal_has_bigheadimgurl();
}
inline void UserInfoExt::clear_bigheadimgurl() {
  _impl_.bigheadimgurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserInfoExt::bigheadimgurl() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bigHeadImgUrl)
  return _internal_bigheadimgurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_bigheadimgurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.bigheadimgurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.bigHeadImgUrl)
}
inline std::string* UserInfoExt::mutable_bigheadimgurl() {
  std::string* _s = _internal_mutable_bigheadimgurl();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.bigHeadImgUrl)
  return _s;
}
inline const std::string& UserInfoExt::_internal_bigheadimgurl() const {
  return _impl_.bigheadimgurl_.Get();
}
inline void UserInfoExt::_internal_set_bigheadimgurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bigheadimgurl_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_bigheadimgurl() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bigheadimgurl_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_bigheadimgurl() {
  // @@protoc_insertion_point(field_release:UserInfoExt.bigHeadImgUrl)
  if (!_internal_has_bigheadimgurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.bigheadimgurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bigheadimgurl_.IsDefault()) {
    _impl_.bigheadimgurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_bigheadimgurl(std::string* bigheadimgurl) {
  if (bigheadimgurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bigheadimgurl_.SetAllocated(bigheadimgurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bigheadimgurl_.IsDefault()) {
    _impl_.bigheadimgurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.bigHeadImgUrl)
}

// optional string smallHeadImgUrl = 10;
inline bool UserInfoExt::_internal_has_smallheadimgurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfoExt::has_smallheadimgurl() const {
  return _internal_has_smallheadimgurl();
}
inline void UserInfoExt::clear_smallheadimgurl() {
  _impl_.smallheadimgurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserInfoExt::smallheadimgurl() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.smallHeadImgUrl)
  return _internal_smallheadimgurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_smallheadimgurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.smallheadimgurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.smallHeadImgUrl)
}
inline std::string* UserInfoExt::mutable_smallheadimgurl() {
  std::string* _s = _internal_mutable_smallheadimgurl();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.smallHeadImgUrl)
  return _s;
}
inline const std::string& UserInfoExt::_internal_smallheadimgurl() const {
  return _impl_.smallheadimgurl_.Get();
}
inline void UserInfoExt::_internal_set_smallheadimgurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.smallheadimgurl_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_smallheadimgurl() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.smallheadimgurl_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_smallheadimgurl() {
  // @@protoc_insertion_point(field_release:UserInfoExt.smallHeadImgUrl)
  if (!_internal_has_smallheadimgurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.smallheadimgurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smallheadimgurl_.IsDefault()) {
    _impl_.smallheadimgurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_smallheadimgurl(std::string* smallheadimgurl) {
  if (smallheadimgurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.smallheadimgurl_.SetAllocated(smallheadimgurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smallheadimgurl_.IsDefault()) {
    _impl_.smallheadimgurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.smallHeadImgUrl)
}

// optional uint32 mainAcctType = 11;
inline bool UserInfoExt::_internal_has_mainaccttype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfoExt::has_mainaccttype() const {
  return _internal_has_mainaccttype();
}
inline void UserInfoExt::clear_mainaccttype() {
  _impl_.mainaccttype_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t UserInfoExt::_internal_mainaccttype() const {
  return _impl_.mainaccttype_;
}
inline uint32_t UserInfoExt::mainaccttype() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.mainAcctType)
  return _internal_mainaccttype();
}
inline void UserInfoExt::_internal_set_mainaccttype(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.mainaccttype_ = value;
}
inline void UserInfoExt::set_mainaccttype(uint32_t value) {
  _internal_set_mainaccttype(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.mainAcctType)
}

// optional .SKBuiltinString_t extXml = 12;
inline bool UserInfoExt::_internal_has_extxml() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extxml_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_extxml() const {
  return _internal_has_extxml();
}
inline const ::SKBuiltinString_t& UserInfoExt::_internal_extxml() const {
  const ::SKBuiltinString_t* p = _impl_.extxml_;
  return p != nullptr ? *p : reinterpret_cast<const ::SKBuiltinString_t&>(
      ::_SKBuiltinString_t_default_instance_);
}
inline const ::SKBuiltinString_t& UserInfoExt::extxml() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.extXml)
  return _internal_extxml();
}
inline void UserInfoExt::unsafe_arena_set_allocated_extxml(
    ::SKBuiltinString_t* extxml) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extxml_);
  }
  _impl_.extxml_ = extxml;
  if (extxml) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.extXml)
}
inline ::SKBuiltinString_t* UserInfoExt::release_extxml() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::SKBuiltinString_t* temp = _impl_.extxml_;
  _impl_.extxml_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SKBuiltinString_t* UserInfoExt::unsafe_arena_release_extxml() {
  // @@protoc_insertion_point(field_release:UserInfoExt.extXml)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::SKBuiltinString_t* temp = _impl_.extxml_;
  _impl_.extxml_ = nullptr;
  return temp;
}
inline ::SKBuiltinString_t* UserInfoExt::_internal_mutable_extxml() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.extxml_ == nullptr) {
    auto* p = CreateMaybeMessage<::SKBuiltinString_t>(GetArenaForAllocation());
    _impl_.extxml_ = p;
  }
  return _impl_.extxml_;
}
inline ::SKBuiltinString_t* UserInfoExt::mutable_extxml() {
  ::SKBuiltinString_t* _msg = _internal_mutable_extxml();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.extXml)
  return _msg;
}
inline void UserInfoExt::set_allocated_extxml(::SKBuiltinString_t* extxml) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extxml_);
  }
  if (extxml) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extxml));
    if (message_arena != submessage_arena) {
      extxml = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extxml, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.extxml_ = extxml;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.extXml)
}

// optional .SafeDeviceList safeDeviceList = 13;
inline bool UserInfoExt::_internal_has_safedevicelist() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.safedevicelist_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_safedevicelist() const {
  return _internal_has_safedevicelist();
}
inline void UserInfoExt::clear_safedevicelist() {
  if (_impl_.safedevicelist_ != nullptr) _impl_.safedevicelist_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::SafeDeviceList& UserInfoExt::_internal_safedevicelist() const {
  const ::SafeDeviceList* p = _impl_.safedevicelist_;
  return p != nullptr ? *p : reinterpret_cast<const ::SafeDeviceList&>(
      ::_SafeDeviceList_default_instance_);
}
inline const ::SafeDeviceList& UserInfoExt::safedevicelist() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.safeDeviceList)
  return _internal_safedevicelist();
}
inline void UserInfoExt::unsafe_arena_set_allocated_safedevicelist(
    ::SafeDeviceList* safedevicelist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.safedevicelist_);
  }
  _impl_.safedevicelist_ = safedevicelist;
  if (safedevicelist) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.safeDeviceList)
}
inline ::SafeDeviceList* UserInfoExt::release_safedevicelist() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::SafeDeviceList* temp = _impl_.safedevicelist_;
  _impl_.safedevicelist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SafeDeviceList* UserInfoExt::unsafe_arena_release_safedevicelist() {
  // @@protoc_insertion_point(field_release:UserInfoExt.safeDeviceList)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::SafeDeviceList* temp = _impl_.safedevicelist_;
  _impl_.safedevicelist_ = nullptr;
  return temp;
}
inline ::SafeDeviceList* UserInfoExt::_internal_mutable_safedevicelist() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.safedevicelist_ == nullptr) {
    auto* p = CreateMaybeMessage<::SafeDeviceList>(GetArenaForAllocation());
    _impl_.safedevicelist_ = p;
  }
  return _impl_.safedevicelist_;
}
inline ::SafeDeviceList* UserInfoExt::mutable_safedevicelist() {
  ::SafeDeviceList* _msg = _internal_mutable_safedevicelist();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.safeDeviceList)
  return _msg;
}
inline void UserInfoExt::set_allocated_safedevicelist(::SafeDeviceList* safedevicelist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.safedevicelist_;
  }
  if (safedevicelist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(safedevicelist);
    if (message_arena != submessage_arena) {
      safedevicelist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safedevicelist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.safedevicelist_ = safedevicelist;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.safeDeviceList)
}

// optional uint32 safeDevice = 14;
inline bool UserInfoExt::_internal_has_safedevice() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfoExt::has_safedevice() const {
  return _internal_has_safedevice();
}
inline void UserInfoExt::clear_safedevice() {
  _impl_.safedevice_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t UserInfoExt::_internal_safedevice() const {
  return _impl_.safedevice_;
}
inline uint32_t UserInfoExt::safedevice() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.safeDevice)
  return _internal_safedevice();
}
inline void UserInfoExt::_internal_set_safedevice(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.safedevice_ = value;
}
inline void UserInfoExt::set_safedevice(uint32_t value) {
  _internal_set_safedevice(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.safeDevice)
}

// optional uint32 grayscaleFlag = 15;
inline bool UserInfoExt::_internal_has_grayscaleflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfoExt::has_grayscaleflag() const {
  return _internal_has_grayscaleflag();
}
inline void UserInfoExt::clear_grayscaleflag() {
  _impl_.grayscaleflag_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline uint32_t UserInfoExt::_internal_grayscaleflag() const {
  return _impl_.grayscaleflag_;
}
inline uint32_t UserInfoExt::grayscaleflag() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.grayscaleFlag)
  return _internal_grayscaleflag();
}
inline void UserInfoExt::_internal_set_grayscaleflag(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.grayscaleflag_ = value;
}
inline void UserInfoExt::set_grayscaleflag(uint32_t value) {
  _internal_set_grayscaleflag(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.grayscaleFlag)
}

// optional string googleContactName = 16;
inline bool UserInfoExt::_internal_has_googlecontactname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfoExt::has_googlecontactname() const {
  return _internal_has_googlecontactname();
}
inline void UserInfoExt::clear_googlecontactname() {
  _impl_.googlecontactname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserInfoExt::googlecontactname() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.googleContactName)
  return _internal_googlecontactname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_googlecontactname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.googlecontactname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.googleContactName)
}
inline std::string* UserInfoExt::mutable_googlecontactname() {
  std::string* _s = _internal_mutable_googlecontactname();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.googleContactName)
  return _s;
}
inline const std::string& UserInfoExt::_internal_googlecontactname() const {
  return _impl_.googlecontactname_.Get();
}
inline void UserInfoExt::_internal_set_googlecontactname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.googlecontactname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_googlecontactname() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.googlecontactname_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_googlecontactname() {
  // @@protoc_insertion_point(field_release:UserInfoExt.googleContactName)
  if (!_internal_has_googlecontactname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.googlecontactname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.googlecontactname_.IsDefault()) {
    _impl_.googlecontactname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_googlecontactname(std::string* googlecontactname) {
  if (googlecontactname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.googlecontactname_.SetAllocated(googlecontactname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.googlecontactname_.IsDefault()) {
    _impl_.googlecontactname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.googleContactName)
}

// optional string idcardNum = 17;
inline bool UserInfoExt::_internal_has_idcardnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfoExt::has_idcardnum() const {
  return _internal_has_idcardnum();
}
inline void UserInfoExt::clear_idcardnum() {
  _impl_.idcardnum_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserInfoExt::idcardnum() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.idcardNum)
  return _internal_idcardnum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_idcardnum(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.idcardnum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.idcardNum)
}
inline std::string* UserInfoExt::mutable_idcardnum() {
  std::string* _s = _internal_mutable_idcardnum();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.idcardNum)
  return _s;
}
inline const std::string& UserInfoExt::_internal_idcardnum() const {
  return _impl_.idcardnum_.Get();
}
inline void UserInfoExt::_internal_set_idcardnum(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.idcardnum_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_idcardnum() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.idcardnum_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_idcardnum() {
  // @@protoc_insertion_point(field_release:UserInfoExt.idcardNum)
  if (!_internal_has_idcardnum()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.idcardnum_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idcardnum_.IsDefault()) {
    _impl_.idcardnum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_idcardnum(std::string* idcardnum) {
  if (idcardnum != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.idcardnum_.SetAllocated(idcardnum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idcardnum_.IsDefault()) {
    _impl_.idcardnum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.idcardNum)
}

// optional string realName = 18;
inline bool UserInfoExt::_internal_has_realname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfoExt::has_realname() const {
  return _internal_has_realname();
}
inline void UserInfoExt::clear_realname() {
  _impl_.realname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& UserInfoExt::realname() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.realName)
  return _internal_realname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_realname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.realname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.realName)
}
inline std::string* UserInfoExt::mutable_realname() {
  std::string* _s = _internal_mutable_realname();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.realName)
  return _s;
}
inline const std::string& UserInfoExt::_internal_realname() const {
  return _impl_.realname_.Get();
}
inline void UserInfoExt::_internal_set_realname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.realname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_realname() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.realname_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_realname() {
  // @@protoc_insertion_point(field_release:UserInfoExt.realName)
  if (!_internal_has_realname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.realname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realname_.IsDefault()) {
    _impl_.realname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_realname(std::string* realname) {
  if (realname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.realname_.SetAllocated(realname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realname_.IsDefault()) {
    _impl_.realname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.realName)
}

// optional string regCountry = 19;
inline bool UserInfoExt::_internal_has_regcountry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserInfoExt::has_regcountry() const {
  return _internal_has_regcountry();
}
inline void UserInfoExt::clear_regcountry() {
  _impl_.regcountry_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& UserInfoExt::regcountry() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.regCountry)
  return _internal_regcountry();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_regcountry(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.regcountry_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.regCountry)
}
inline std::string* UserInfoExt::mutable_regcountry() {
  std::string* _s = _internal_mutable_regcountry();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.regCountry)
  return _s;
}
inline const std::string& UserInfoExt::_internal_regcountry() const {
  return _impl_.regcountry_.Get();
}
inline void UserInfoExt::_internal_set_regcountry(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.regcountry_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_regcountry() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.regcountry_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_regcountry() {
  // @@protoc_insertion_point(field_release:UserInfoExt.regCountry)
  if (!_internal_has_regcountry()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.regcountry_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.regcountry_.IsDefault()) {
    _impl_.regcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_regcountry(std::string* regcountry) {
  if (regcountry != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.regcountry_.SetAllocated(regcountry, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.regcountry_.IsDefault()) {
    _impl_.regcountry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.regCountry)
}

// optional string bbppid = 20;
inline bool UserInfoExt::_internal_has_bbppid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserInfoExt::has_bbppid() const {
  return _internal_has_bbppid();
}
inline void UserInfoExt::clear_bbppid() {
  _impl_.bbppid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& UserInfoExt::bbppid() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bbppid)
  return _internal_bbppid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_bbppid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.bbppid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.bbppid)
}
inline std::string* UserInfoExt::mutable_bbppid() {
  std::string* _s = _internal_mutable_bbppid();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.bbppid)
  return _s;
}
inline const std::string& UserInfoExt::_internal_bbppid() const {
  return _impl_.bbppid_.Get();
}
inline void UserInfoExt::_internal_set_bbppid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.bbppid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_bbppid() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.bbppid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_bbppid() {
  // @@protoc_insertion_point(field_release:UserInfoExt.bbppid)
  if (!_internal_has_bbppid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.bbppid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbppid_.IsDefault()) {
    _impl_.bbppid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_bbppid(std::string* bbppid) {
  if (bbppid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.bbppid_.SetAllocated(bbppid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbppid_.IsDefault()) {
    _impl_.bbppid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.bbppid)
}

// optional string bbpin = 21;
inline bool UserInfoExt::_internal_has_bbpin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserInfoExt::has_bbpin() const {
  return _internal_has_bbpin();
}
inline void UserInfoExt::clear_bbpin() {
  _impl_.bbpin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& UserInfoExt::bbpin() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bbpin)
  return _internal_bbpin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_bbpin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.bbpin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.bbpin)
}
inline std::string* UserInfoExt::mutable_bbpin() {
  std::string* _s = _internal_mutable_bbpin();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.bbpin)
  return _s;
}
inline const std::string& UserInfoExt::_internal_bbpin() const {
  return _impl_.bbpin_.Get();
}
inline void UserInfoExt::_internal_set_bbpin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.bbpin_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_bbpin() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.bbpin_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_bbpin() {
  // @@protoc_insertion_point(field_release:UserInfoExt.bbpin)
  if (!_internal_has_bbpin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.bbpin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbpin_.IsDefault()) {
    _impl_.bbpin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_bbpin(std::string* bbpin) {
  if (bbpin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.bbpin_.SetAllocated(bbpin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbpin_.IsDefault()) {
    _impl_.bbpin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.bbpin)
}

// optional string bbmnickName = 22;
inline bool UserInfoExt::_internal_has_bbmnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UserInfoExt::has_bbmnickname() const {
  return _internal_has_bbmnickname();
}
inline void UserInfoExt::clear_bbmnickname() {
  _impl_.bbmnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& UserInfoExt::bbmnickname() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bbmnickName)
  return _internal_bbmnickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_bbmnickname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.bbmnickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.bbmnickName)
}
inline std::string* UserInfoExt::mutable_bbmnickname() {
  std::string* _s = _internal_mutable_bbmnickname();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.bbmnickName)
  return _s;
}
inline const std::string& UserInfoExt::_internal_bbmnickname() const {
  return _impl_.bbmnickname_.Get();
}
inline void UserInfoExt::_internal_set_bbmnickname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.bbmnickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_bbmnickname() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.bbmnickname_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_bbmnickname() {
  // @@protoc_insertion_point(field_release:UserInfoExt.bbmnickName)
  if (!_internal_has_bbmnickname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.bbmnickname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbmnickname_.IsDefault()) {
    _impl_.bbmnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_bbmnickname(std::string* bbmnickname) {
  if (bbmnickname != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.bbmnickname_.SetAllocated(bbmnickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bbmnickname_.IsDefault()) {
    _impl_.bbmnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.bbmnickName)
}

// optional .LinkedinContactItem linkedinContactItem = 23;
inline bool UserInfoExt::_internal_has_linkedincontactitem() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linkedincontactitem_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_linkedincontactitem() const {
  return _internal_has_linkedincontactitem();
}
inline void UserInfoExt::clear_linkedincontactitem() {
  if (_impl_.linkedincontactitem_ != nullptr) _impl_.linkedincontactitem_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::LinkedinContactItem& UserInfoExt::_internal_linkedincontactitem() const {
  const ::LinkedinContactItem* p = _impl_.linkedincontactitem_;
  return p != nullptr ? *p : reinterpret_cast<const ::LinkedinContactItem&>(
      ::_LinkedinContactItem_default_instance_);
}
inline const ::LinkedinContactItem& UserInfoExt::linkedincontactitem() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.linkedinContactItem)
  return _internal_linkedincontactitem();
}
inline void UserInfoExt::unsafe_arena_set_allocated_linkedincontactitem(
    ::LinkedinContactItem* linkedincontactitem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkedincontactitem_);
  }
  _impl_.linkedincontactitem_ = linkedincontactitem;
  if (linkedincontactitem) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.linkedinContactItem)
}
inline ::LinkedinContactItem* UserInfoExt::release_linkedincontactitem() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::LinkedinContactItem* temp = _impl_.linkedincontactitem_;
  _impl_.linkedincontactitem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LinkedinContactItem* UserInfoExt::unsafe_arena_release_linkedincontactitem() {
  // @@protoc_insertion_point(field_release:UserInfoExt.linkedinContactItem)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::LinkedinContactItem* temp = _impl_.linkedincontactitem_;
  _impl_.linkedincontactitem_ = nullptr;
  return temp;
}
inline ::LinkedinContactItem* UserInfoExt::_internal_mutable_linkedincontactitem() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.linkedincontactitem_ == nullptr) {
    auto* p = CreateMaybeMessage<::LinkedinContactItem>(GetArenaForAllocation());
    _impl_.linkedincontactitem_ = p;
  }
  return _impl_.linkedincontactitem_;
}
inline ::LinkedinContactItem* UserInfoExt::mutable_linkedincontactitem() {
  ::LinkedinContactItem* _msg = _internal_mutable_linkedincontactitem();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.linkedinContactItem)
  return _msg;
}
inline void UserInfoExt::set_allocated_linkedincontactitem(::LinkedinContactItem* linkedincontactitem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linkedincontactitem_;
  }
  if (linkedincontactitem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linkedincontactitem);
    if (message_arena != submessage_arena) {
      linkedincontactitem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkedincontactitem, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.linkedincontactitem_ = linkedincontactitem;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.linkedinContactItem)
}

// optional string kfinfo = 24;
inline bool UserInfoExt::_internal_has_kfinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UserInfoExt::has_kfinfo() const {
  return _internal_has_kfinfo();
}
inline void UserInfoExt::clear_kfinfo() {
  _impl_.kfinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& UserInfoExt::kfinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.kfinfo)
  return _internal_kfinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_kfinfo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.kfinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.kfinfo)
}
inline std::string* UserInfoExt::mutable_kfinfo() {
  std::string* _s = _internal_mutable_kfinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.kfinfo)
  return _s;
}
inline const std::string& UserInfoExt::_internal_kfinfo() const {
  return _impl_.kfinfo_.Get();
}
inline void UserInfoExt::_internal_set_kfinfo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.kfinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_kfinfo() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.kfinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_kfinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.kfinfo)
  if (!_internal_has_kfinfo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.kfinfo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kfinfo_.IsDefault()) {
    _impl_.kfinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_kfinfo(std::string* kfinfo) {
  if (kfinfo != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.kfinfo_.SetAllocated(kfinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kfinfo_.IsDefault()) {
    _impl_.kfinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.kfinfo)
}

// optional .PatternLockInfo patternLockInfo = 25;
inline bool UserInfoExt::_internal_has_patternlockinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.patternlockinfo_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_patternlockinfo() const {
  return _internal_has_patternlockinfo();
}
inline void UserInfoExt::clear_patternlockinfo() {
  if (_impl_.patternlockinfo_ != nullptr) _impl_.patternlockinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::PatternLockInfo& UserInfoExt::_internal_patternlockinfo() const {
  const ::PatternLockInfo* p = _impl_.patternlockinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PatternLockInfo&>(
      ::_PatternLockInfo_default_instance_);
}
inline const ::PatternLockInfo& UserInfoExt::patternlockinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.patternLockInfo)
  return _internal_patternlockinfo();
}
inline void UserInfoExt::unsafe_arena_set_allocated_patternlockinfo(
    ::PatternLockInfo* patternlockinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.patternlockinfo_);
  }
  _impl_.patternlockinfo_ = patternlockinfo;
  if (patternlockinfo) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.patternLockInfo)
}
inline ::PatternLockInfo* UserInfoExt::release_patternlockinfo() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::PatternLockInfo* temp = _impl_.patternlockinfo_;
  _impl_.patternlockinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PatternLockInfo* UserInfoExt::unsafe_arena_release_patternlockinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.patternLockInfo)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::PatternLockInfo* temp = _impl_.patternlockinfo_;
  _impl_.patternlockinfo_ = nullptr;
  return temp;
}
inline ::PatternLockInfo* UserInfoExt::_internal_mutable_patternlockinfo() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.patternlockinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PatternLockInfo>(GetArenaForAllocation());
    _impl_.patternlockinfo_ = p;
  }
  return _impl_.patternlockinfo_;
}
inline ::PatternLockInfo* UserInfoExt::mutable_patternlockinfo() {
  ::PatternLockInfo* _msg = _internal_mutable_patternlockinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.patternLockInfo)
  return _msg;
}
inline void UserInfoExt::set_allocated_patternlockinfo(::PatternLockInfo* patternlockinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.patternlockinfo_;
  }
  if (patternlockinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(patternlockinfo);
    if (message_arena != submessage_arena) {
      patternlockinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, patternlockinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.patternlockinfo_ = patternlockinfo;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.patternLockInfo)
}

// optional string securityDeviceId = 26;
inline bool UserInfoExt::_internal_has_securitydeviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool UserInfoExt::has_securitydeviceid() const {
  return _internal_has_securitydeviceid();
}
inline void UserInfoExt::clear_securitydeviceid() {
  _impl_.securitydeviceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& UserInfoExt::securitydeviceid() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.securityDeviceId)
  return _internal_securitydeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_securitydeviceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.securitydeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.securityDeviceId)
}
inline std::string* UserInfoExt::mutable_securitydeviceid() {
  std::string* _s = _internal_mutable_securitydeviceid();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.securityDeviceId)
  return _s;
}
inline const std::string& UserInfoExt::_internal_securitydeviceid() const {
  return _impl_.securitydeviceid_.Get();
}
inline void UserInfoExt::_internal_set_securitydeviceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.securitydeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_securitydeviceid() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.securitydeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_securitydeviceid() {
  // @@protoc_insertion_point(field_release:UserInfoExt.securityDeviceId)
  if (!_internal_has_securitydeviceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.securitydeviceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitydeviceid_.IsDefault()) {
    _impl_.securitydeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_securitydeviceid(std::string* securitydeviceid) {
  if (securitydeviceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.securitydeviceid_.SetAllocated(securitydeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitydeviceid_.IsDefault()) {
    _impl_.securitydeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.securityDeviceId)
}

// optional uint32 payWalletType = 27;
inline bool UserInfoExt::_internal_has_paywallettype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfoExt::has_paywallettype() const {
  return _internal_has_paywallettype();
}
inline void UserInfoExt::clear_paywallettype() {
  _impl_.paywallettype_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline uint32_t UserInfoExt::_internal_paywallettype() const {
  return _impl_.paywallettype_;
}
inline uint32_t UserInfoExt::paywallettype() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.payWalletType)
  return _internal_paywallettype();
}
inline void UserInfoExt::_internal_set_paywallettype(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.paywallettype_ = value;
}
inline void UserInfoExt::set_paywallettype(uint32_t value) {
  _internal_set_paywallettype(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.payWalletType)
}

// optional string weiDianInfo = 28;
inline bool UserInfoExt::_internal_has_weidianinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool UserInfoExt::has_weidianinfo() const {
  return _internal_has_weidianinfo();
}
inline void UserInfoExt::clear_weidianinfo() {
  _impl_.weidianinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& UserInfoExt::weidianinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.weiDianInfo)
  return _internal_weidianinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_weidianinfo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.weidianinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.weiDianInfo)
}
inline std::string* UserInfoExt::mutable_weidianinfo() {
  std::string* _s = _internal_mutable_weidianinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.weiDianInfo)
  return _s;
}
inline const std::string& UserInfoExt::_internal_weidianinfo() const {
  return _impl_.weidianinfo_.Get();
}
inline void UserInfoExt::_internal_set_weidianinfo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.weidianinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_weidianinfo() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.weidianinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_weidianinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.weiDianInfo)
  if (!_internal_has_weidianinfo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.weidianinfo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weidianinfo_.IsDefault()) {
    _impl_.weidianinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_weidianinfo(std::string* weidianinfo) {
  if (weidianinfo != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.weidianinfo_.SetAllocated(weidianinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weidianinfo_.IsDefault()) {
    _impl_.weidianinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.weiDianInfo)
}

// optional uint32 walletRegion = 29;
inline bool UserInfoExt::_internal_has_walletregion() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfoExt::has_walletregion() const {
  return _internal_has_walletregion();
}
inline void UserInfoExt::clear_walletregion() {
  _impl_.walletregion_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline uint32_t UserInfoExt::_internal_walletregion() const {
  return _impl_.walletregion_;
}
inline uint32_t UserInfoExt::walletregion() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.walletRegion)
  return _internal_walletregion();
}
inline void UserInfoExt::_internal_set_walletregion(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.walletregion_ = value;
}
inline void UserInfoExt::set_walletregion(uint32_t value) {
  _internal_set_walletregion(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.walletRegion)
}

// optional uint64 extStatus = 30;
inline bool UserInfoExt::_internal_has_extstatus() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfoExt::has_extstatus() const {
  return _internal_has_extstatus();
}
inline void UserInfoExt::clear_extstatus() {
  _impl_.extstatus_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline uint64_t UserInfoExt::_internal_extstatus() const {
  return _impl_.extstatus_;
}
inline uint64_t UserInfoExt::extstatus() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.extStatus)
  return _internal_extstatus();
}
inline void UserInfoExt::_internal_set_extstatus(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.extstatus_ = value;
}
inline void UserInfoExt::set_extstatus(uint64_t value) {
  _internal_set_extstatus(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.extStatus)
}

// optional string f2FpushSound = 31;
inline bool UserInfoExt::_internal_has_f2fpushsound() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool UserInfoExt::has_f2fpushsound() const {
  return _internal_has_f2fpushsound();
}
inline void UserInfoExt::clear_f2fpushsound() {
  _impl_.f2fpushsound_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& UserInfoExt::f2fpushsound() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.f2FpushSound)
  return _internal_f2fpushsound();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_f2fpushsound(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.f2fpushsound_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.f2FpushSound)
}
inline std::string* UserInfoExt::mutable_f2fpushsound() {
  std::string* _s = _internal_mutable_f2fpushsound();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.f2FpushSound)
  return _s;
}
inline const std::string& UserInfoExt::_internal_f2fpushsound() const {
  return _impl_.f2fpushsound_.Get();
}
inline void UserInfoExt::_internal_set_f2fpushsound(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.f2fpushsound_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_f2fpushsound() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.f2fpushsound_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_f2fpushsound() {
  // @@protoc_insertion_point(field_release:UserInfoExt.f2FpushSound)
  if (!_internal_has_f2fpushsound()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.f2fpushsound_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.f2fpushsound_.IsDefault()) {
    _impl_.f2fpushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_f2fpushsound(std::string* f2fpushsound) {
  if (f2fpushsound != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.f2fpushsound_.SetAllocated(f2fpushsound, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.f2fpushsound_.IsDefault()) {
    _impl_.f2fpushsound_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.f2FpushSound)
}

// optional uint32 userStatus = 32;
inline bool UserInfoExt::_internal_has_userstatus() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfoExt::has_userstatus() const {
  return _internal_has_userstatus();
}
inline void UserInfoExt::clear_userstatus() {
  _impl_.userstatus_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline uint32_t UserInfoExt::_internal_userstatus() const {
  return _impl_.userstatus_;
}
inline uint32_t UserInfoExt::userstatus() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.userStatus)
  return _internal_userstatus();
}
inline void UserInfoExt::_internal_set_userstatus(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.userstatus_ = value;
}
inline void UserInfoExt::set_userstatus(uint32_t value) {
  _internal_set_userstatus(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.userStatus)
}

// optional uint64 paySetting = 34;
inline bool UserInfoExt::_internal_has_paysetting() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfoExt::has_paysetting() const {
  return _internal_has_paysetting();
}
inline void UserInfoExt::clear_paysetting() {
  _impl_.paysetting_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline uint64_t UserInfoExt::_internal_paysetting() const {
  return _impl_.paysetting_;
}
inline uint64_t UserInfoExt::paysetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.paySetting)
  return _internal_paysetting();
}
inline void UserInfoExt::_internal_set_paysetting(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.paysetting_ = value;
}
inline void UserInfoExt::set_paysetting(uint64_t value) {
  _internal_set_paysetting(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.paySetting)
}

// optional string bindXmail = 37;
inline bool UserInfoExt::_internal_has_bindxmail() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool UserInfoExt::has_bindxmail() const {
  return _internal_has_bindxmail();
}
inline void UserInfoExt::clear_bindxmail() {
  _impl_.bindxmail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& UserInfoExt::bindxmail() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.bindXmail)
  return _internal_bindxmail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_bindxmail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.bindxmail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.bindXmail)
}
inline std::string* UserInfoExt::mutable_bindxmail() {
  std::string* _s = _internal_mutable_bindxmail();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.bindXmail)
  return _s;
}
inline const std::string& UserInfoExt::_internal_bindxmail() const {
  return _impl_.bindxmail_.Get();
}
inline void UserInfoExt::_internal_set_bindxmail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.bindxmail_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_bindxmail() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.bindxmail_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_bindxmail() {
  // @@protoc_insertion_point(field_release:UserInfoExt.bindXmail)
  if (!_internal_has_bindxmail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.bindxmail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindxmail_.IsDefault()) {
    _impl_.bindxmail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_bindxmail(std::string* bindxmail) {
  if (bindxmail != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.bindxmail_.SetAllocated(bindxmail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindxmail_.IsDefault()) {
    _impl_.bindxmail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.bindXmail)
}

// optional string patSuffix = 38;
inline bool UserInfoExt::_internal_has_patsuffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool UserInfoExt::has_patsuffix() const {
  return _internal_has_patsuffix();
}
inline void UserInfoExt::clear_patsuffix() {
  _impl_.patsuffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& UserInfoExt::patsuffix() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.patSuffix)
  return _internal_patsuffix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_patsuffix(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00040000u;
 _impl_.patsuffix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.patSuffix)
}
inline std::string* UserInfoExt::mutable_patsuffix() {
  std::string* _s = _internal_mutable_patsuffix();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.patSuffix)
  return _s;
}
inline const std::string& UserInfoExt::_internal_patsuffix() const {
  return _impl_.patsuffix_.Get();
}
inline void UserInfoExt::_internal_set_patsuffix(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.patsuffix_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_patsuffix() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.patsuffix_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_patsuffix() {
  // @@protoc_insertion_point(field_release:UserInfoExt.patSuffix)
  if (!_internal_has_patsuffix()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* p = _impl_.patsuffix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.patsuffix_.IsDefault()) {
    _impl_.patsuffix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_patsuffix(std::string* patsuffix) {
  if (patsuffix != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.patsuffix_.SetAllocated(patsuffix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.patsuffix_.IsDefault()) {
    _impl_.patsuffix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.patSuffix)
}

// optional uint32 patSuffixVersion = 39;
inline bool UserInfoExt::_internal_has_patsuffixversion() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool UserInfoExt::has_patsuffixversion() const {
  return _internal_has_patsuffixversion();
}
inline void UserInfoExt::clear_patsuffixversion() {
  _impl_.patsuffixversion_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline uint32_t UserInfoExt::_internal_patsuffixversion() const {
  return _impl_.patsuffixversion_;
}
inline uint32_t UserInfoExt::patsuffixversion() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.patSuffixVersion)
  return _internal_patsuffixversion();
}
inline void UserInfoExt::_internal_set_patsuffixversion(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.patsuffixversion_ = value;
}
inline void UserInfoExt::set_patsuffixversion(uint32_t value) {
  _internal_set_patsuffixversion(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.patSuffixVersion)
}

// optional uint32 teenagerModeFinderSetting = 44;
inline bool UserInfoExt::_internal_has_teenagermodefindersetting() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool UserInfoExt::has_teenagermodefindersetting() const {
  return _internal_has_teenagermodefindersetting();
}
inline void UserInfoExt::clear_teenagermodefindersetting() {
  _impl_.teenagermodefindersetting_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline uint32_t UserInfoExt::_internal_teenagermodefindersetting() const {
  return _impl_.teenagermodefindersetting_;
}
inline uint32_t UserInfoExt::teenagermodefindersetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.teenagerModeFinderSetting)
  return _internal_teenagermodefindersetting();
}
inline void UserInfoExt::_internal_set_teenagermodefindersetting(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.teenagermodefindersetting_ = value;
}
inline void UserInfoExt::set_teenagermodefindersetting(uint32_t value) {
  _internal_set_teenagermodefindersetting(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.teenagerModeFinderSetting)
}

// optional uint32 teenagerModeBizAcctSetting = 45;
inline bool UserInfoExt::_internal_has_teenagermodebizacctsetting() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool UserInfoExt::has_teenagermodebizacctsetting() const {
  return _internal_has_teenagermodebizacctsetting();
}
inline void UserInfoExt::clear_teenagermodebizacctsetting() {
  _impl_.teenagermodebizacctsetting_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline uint32_t UserInfoExt::_internal_teenagermodebizacctsetting() const {
  return _impl_.teenagermodebizacctsetting_;
}
inline uint32_t UserInfoExt::teenagermodebizacctsetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.teenagerModeBizAcctSetting)
  return _internal_teenagermodebizacctsetting();
}
inline void UserInfoExt::_internal_set_teenagermodebizacctsetting(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.teenagermodebizacctsetting_ = value;
}
inline void UserInfoExt::set_teenagermodebizacctsetting(uint32_t value) {
  _internal_set_teenagermodebizacctsetting(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.teenagerModeBizAcctSetting)
}

// optional uint32 teenagerModeMiniProgramSetting = 46;
inline bool UserInfoExt::_internal_has_teenagermodeminiprogramsetting() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool UserInfoExt::has_teenagermodeminiprogramsetting() const {
  return _internal_has_teenagermodeminiprogramsetting();
}
inline void UserInfoExt::clear_teenagermodeminiprogramsetting() {
  _impl_.teenagermodeminiprogramsetting_ = 0u;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline uint32_t UserInfoExt::_internal_teenagermodeminiprogramsetting() const {
  return _impl_.teenagermodeminiprogramsetting_;
}
inline uint32_t UserInfoExt::teenagermodeminiprogramsetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.teenagerModeMiniProgramSetting)
  return _internal_teenagermodeminiprogramsetting();
}
inline void UserInfoExt::_internal_set_teenagermodeminiprogramsetting(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.teenagermodeminiprogramsetting_ = value;
}
inline void UserInfoExt::set_teenagermodeminiprogramsetting(uint32_t value) {
  _internal_set_teenagermodeminiprogramsetting(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.teenagerModeMiniProgramSetting)
}

// optional .XAgreementInfo xagreementInfo = 47;
inline bool UserInfoExt::_internal_has_xagreementinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.xagreementinfo_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_xagreementinfo() const {
  return _internal_has_xagreementinfo();
}
inline void UserInfoExt::clear_xagreementinfo() {
  if (_impl_.xagreementinfo_ != nullptr) _impl_.xagreementinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::XAgreementInfo& UserInfoExt::_internal_xagreementinfo() const {
  const ::XAgreementInfo* p = _impl_.xagreementinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::XAgreementInfo&>(
      ::_XAgreementInfo_default_instance_);
}
inline const ::XAgreementInfo& UserInfoExt::xagreementinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.xagreementInfo)
  return _internal_xagreementinfo();
}
inline void UserInfoExt::unsafe_arena_set_allocated_xagreementinfo(
    ::XAgreementInfo* xagreementinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.xagreementinfo_);
  }
  _impl_.xagreementinfo_ = xagreementinfo;
  if (xagreementinfo) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.xagreementInfo)
}
inline ::XAgreementInfo* UserInfoExt::release_xagreementinfo() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::XAgreementInfo* temp = _impl_.xagreementinfo_;
  _impl_.xagreementinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XAgreementInfo* UserInfoExt::unsafe_arena_release_xagreementinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.xagreementInfo)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::XAgreementInfo* temp = _impl_.xagreementinfo_;
  _impl_.xagreementinfo_ = nullptr;
  return temp;
}
inline ::XAgreementInfo* UserInfoExt::_internal_mutable_xagreementinfo() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.xagreementinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::XAgreementInfo>(GetArenaForAllocation());
    _impl_.xagreementinfo_ = p;
  }
  return _impl_.xagreementinfo_;
}
inline ::XAgreementInfo* UserInfoExt::mutable_xagreementinfo() {
  ::XAgreementInfo* _msg = _internal_mutable_xagreementinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.xagreementInfo)
  return _msg;
}
inline void UserInfoExt::set_allocated_xagreementinfo(::XAgreementInfo* xagreementinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.xagreementinfo_;
  }
  if (xagreementinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xagreementinfo);
    if (message_arena != submessage_arena) {
      xagreementinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xagreementinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.xagreementinfo_ = xagreementinfo;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.xagreementInfo)
}

// optional string textStatusId = 49;
inline bool UserInfoExt::_internal_has_textstatusid() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool UserInfoExt::has_textstatusid() const {
  return _internal_has_textstatusid();
}
inline void UserInfoExt::clear_textstatusid() {
  _impl_.textstatusid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& UserInfoExt::textstatusid() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.textStatusId)
  return _internal_textstatusid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_textstatusid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00080000u;
 _impl_.textstatusid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.textStatusId)
}
inline std::string* UserInfoExt::mutable_textstatusid() {
  std::string* _s = _internal_mutable_textstatusid();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.textStatusId)
  return _s;
}
inline const std::string& UserInfoExt::_internal_textstatusid() const {
  return _impl_.textstatusid_.Get();
}
inline void UserInfoExt::_internal_set_textstatusid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.textstatusid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_textstatusid() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.textstatusid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_textstatusid() {
  // @@protoc_insertion_point(field_release:UserInfoExt.textStatusId)
  if (!_internal_has_textstatusid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* p = _impl_.textstatusid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textstatusid_.IsDefault()) {
    _impl_.textstatusid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_textstatusid(std::string* textstatusid) {
  if (textstatusid != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.textstatusid_.SetAllocated(textstatusid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textstatusid_.IsDefault()) {
    _impl_.textstatusid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.textStatusId)
}

// optional string textStatusExtInfo = 51;
inline bool UserInfoExt::_internal_has_textstatusextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool UserInfoExt::has_textstatusextinfo() const {
  return _internal_has_textstatusextinfo();
}
inline void UserInfoExt::clear_textstatusextinfo() {
  _impl_.textstatusextinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& UserInfoExt::textstatusextinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.textStatusExtInfo)
  return _internal_textstatusextinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_textstatusextinfo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00100000u;
 _impl_.textstatusextinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.textStatusExtInfo)
}
inline std::string* UserInfoExt::mutable_textstatusextinfo() {
  std::string* _s = _internal_mutable_textstatusextinfo();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.textStatusExtInfo)
  return _s;
}
inline const std::string& UserInfoExt::_internal_textstatusextinfo() const {
  return _impl_.textstatusextinfo_.Get();
}
inline void UserInfoExt::_internal_set_textstatusextinfo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.textstatusextinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_textstatusextinfo() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.textstatusextinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_textstatusextinfo() {
  // @@protoc_insertion_point(field_release:UserInfoExt.textStatusExtInfo)
  if (!_internal_has_textstatusextinfo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* p = _impl_.textstatusextinfo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textstatusextinfo_.IsDefault()) {
    _impl_.textstatusextinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_textstatusextinfo(std::string* textstatusextinfo) {
  if (textstatusextinfo != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.textstatusextinfo_.SetAllocated(textstatusextinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textstatusextinfo_.IsDefault()) {
    _impl_.textstatusextinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.textStatusExtInfo)
}

// optional string salt = 52;
inline bool UserInfoExt::_internal_has_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool UserInfoExt::has_salt() const {
  return _internal_has_salt();
}
inline void UserInfoExt::clear_salt() {
  _impl_.salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const std::string& UserInfoExt::salt() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfoExt::set_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00200000u;
 _impl_.salt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfoExt.salt)
}
inline std::string* UserInfoExt::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.salt)
  return _s;
}
inline const std::string& UserInfoExt::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void UserInfoExt::_internal_set_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfoExt::_internal_mutable_salt() {
  _impl_._has_bits_[0] |= 0x00200000u;
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfoExt::release_salt() {
  // @@protoc_insertion_point(field_release:UserInfoExt.salt)
  if (!_internal_has_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00200000u;
  auto* p = _impl_.salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfoExt::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.salt)
}

// optional uint64 finderSetting = 53;
inline bool UserInfoExt::_internal_has_findersetting() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool UserInfoExt::has_findersetting() const {
  return _internal_has_findersetting();
}
inline void UserInfoExt::clear_findersetting() {
  _impl_.findersetting_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline uint64_t UserInfoExt::_internal_findersetting() const {
  return _impl_.findersetting_;
}
inline uint64_t UserInfoExt::findersetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.finderSetting)
  return _internal_findersetting();
}
inline void UserInfoExt::_internal_set_findersetting(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.findersetting_ = value;
}
inline void UserInfoExt::set_findersetting(uint64_t value) {
  _internal_set_findersetting(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.finderSetting)
}

// optional .RingBackSetting ringBackSetting = 55;
inline bool UserInfoExt::_internal_has_ringbacksetting() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ringbacksetting_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_ringbacksetting() const {
  return _internal_has_ringbacksetting();
}
inline void UserInfoExt::clear_ringbacksetting() {
  if (_impl_.ringbacksetting_ != nullptr) _impl_.ringbacksetting_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::RingBackSetting& UserInfoExt::_internal_ringbacksetting() const {
  const ::RingBackSetting* p = _impl_.ringbacksetting_;
  return p != nullptr ? *p : reinterpret_cast<const ::RingBackSetting&>(
      ::_RingBackSetting_default_instance_);
}
inline const ::RingBackSetting& UserInfoExt::ringbacksetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.ringBackSetting)
  return _internal_ringbacksetting();
}
inline void UserInfoExt::unsafe_arena_set_allocated_ringbacksetting(
    ::RingBackSetting* ringbacksetting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ringbacksetting_);
  }
  _impl_.ringbacksetting_ = ringbacksetting;
  if (ringbacksetting) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.ringBackSetting)
}
inline ::RingBackSetting* UserInfoExt::release_ringbacksetting() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::RingBackSetting* temp = _impl_.ringbacksetting_;
  _impl_.ringbacksetting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RingBackSetting* UserInfoExt::unsafe_arena_release_ringbacksetting() {
  // @@protoc_insertion_point(field_release:UserInfoExt.ringBackSetting)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::RingBackSetting* temp = _impl_.ringbacksetting_;
  _impl_.ringbacksetting_ = nullptr;
  return temp;
}
inline ::RingBackSetting* UserInfoExt::_internal_mutable_ringbacksetting() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.ringbacksetting_ == nullptr) {
    auto* p = CreateMaybeMessage<::RingBackSetting>(GetArenaForAllocation());
    _impl_.ringbacksetting_ = p;
  }
  return _impl_.ringbacksetting_;
}
inline ::RingBackSetting* UserInfoExt::mutable_ringbacksetting() {
  ::RingBackSetting* _msg = _internal_mutable_ringbacksetting();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.ringBackSetting)
  return _msg;
}
inline void UserInfoExt::set_allocated_ringbacksetting(::RingBackSetting* ringbacksetting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ringbacksetting_;
  }
  if (ringbacksetting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ringbacksetting);
    if (message_arena != submessage_arena) {
      ringbacksetting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ringbacksetting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.ringbacksetting_ = ringbacksetting;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.ringBackSetting)
}

// optional uint32 smcryptoFlag = 56;
inline bool UserInfoExt::_internal_has_smcryptoflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool UserInfoExt::has_smcryptoflag() const {
  return _internal_has_smcryptoflag();
}
inline void UserInfoExt::clear_smcryptoflag() {
  _impl_.smcryptoflag_ = 0u;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline uint32_t UserInfoExt::_internal_smcryptoflag() const {
  return _impl_.smcryptoflag_;
}
inline uint32_t UserInfoExt::smcryptoflag() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.smcryptoFlag)
  return _internal_smcryptoflag();
}
inline void UserInfoExt::_internal_set_smcryptoflag(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.smcryptoflag_ = value;
}
inline void UserInfoExt::set_smcryptoflag(uint32_t value) {
  _internal_set_smcryptoflag(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.smcryptoFlag)
}

// optional .NewRingBackSetting globalRingBackSetting = 57;
inline bool UserInfoExt::_internal_has_globalringbacksetting() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.globalringbacksetting_ != nullptr);
  return value;
}
inline bool UserInfoExt::has_globalringbacksetting() const {
  return _internal_has_globalringbacksetting();
}
inline void UserInfoExt::clear_globalringbacksetting() {
  if (_impl_.globalringbacksetting_ != nullptr) _impl_.globalringbacksetting_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::NewRingBackSetting& UserInfoExt::_internal_globalringbacksetting() const {
  const ::NewRingBackSetting* p = _impl_.globalringbacksetting_;
  return p != nullptr ? *p : reinterpret_cast<const ::NewRingBackSetting&>(
      ::_NewRingBackSetting_default_instance_);
}
inline const ::NewRingBackSetting& UserInfoExt::globalringbacksetting() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.globalRingBackSetting)
  return _internal_globalringbacksetting();
}
inline void UserInfoExt::unsafe_arena_set_allocated_globalringbacksetting(
    ::NewRingBackSetting* globalringbacksetting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.globalringbacksetting_);
  }
  _impl_.globalringbacksetting_ = globalringbacksetting;
  if (globalringbacksetting) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserInfoExt.globalRingBackSetting)
}
inline ::NewRingBackSetting* UserInfoExt::release_globalringbacksetting() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::NewRingBackSetting* temp = _impl_.globalringbacksetting_;
  _impl_.globalringbacksetting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NewRingBackSetting* UserInfoExt::unsafe_arena_release_globalringbacksetting() {
  // @@protoc_insertion_point(field_release:UserInfoExt.globalRingBackSetting)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::NewRingBackSetting* temp = _impl_.globalringbacksetting_;
  _impl_.globalringbacksetting_ = nullptr;
  return temp;
}
inline ::NewRingBackSetting* UserInfoExt::_internal_mutable_globalringbacksetting() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.globalringbacksetting_ == nullptr) {
    auto* p = CreateMaybeMessage<::NewRingBackSetting>(GetArenaForAllocation());
    _impl_.globalringbacksetting_ = p;
  }
  return _impl_.globalringbacksetting_;
}
inline ::NewRingBackSetting* UserInfoExt::mutable_globalringbacksetting() {
  ::NewRingBackSetting* _msg = _internal_mutable_globalringbacksetting();
  // @@protoc_insertion_point(field_mutable:UserInfoExt.globalRingBackSetting)
  return _msg;
}
inline void UserInfoExt::set_allocated_globalringbacksetting(::NewRingBackSetting* globalringbacksetting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.globalringbacksetting_;
  }
  if (globalringbacksetting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(globalringbacksetting);
    if (message_arena != submessage_arena) {
      globalringbacksetting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, globalringbacksetting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.globalringbacksetting_ = globalringbacksetting;
  // @@protoc_insertion_point(field_set_allocated:UserInfoExt.globalRingBackSetting)
}

// optional uint32 newcomeMsgDefaultVoiceNumber = 58;
inline bool UserInfoExt::_internal_has_newcomemsgdefaultvoicenumber() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool UserInfoExt::has_newcomemsgdefaultvoicenumber() const {
  return _internal_has_newcomemsgdefaultvoicenumber();
}
inline void UserInfoExt::clear_newcomemsgdefaultvoicenumber() {
  _impl_.newcomemsgdefaultvoicenumber_ = 0u;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline uint32_t UserInfoExt::_internal_newcomemsgdefaultvoicenumber() const {
  return _impl_.newcomemsgdefaultvoicenumber_;
}
inline uint32_t UserInfoExt::newcomemsgdefaultvoicenumber() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.newcomeMsgDefaultVoiceNumber)
  return _internal_newcomemsgdefaultvoicenumber();
}
inline void UserInfoExt::_internal_set_newcomemsgdefaultvoicenumber(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.newcomemsgdefaultvoicenumber_ = value;
}
inline void UserInfoExt::set_newcomemsgdefaultvoicenumber(uint32_t value) {
  _internal_set_newcomemsgdefaultvoicenumber(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.newcomeMsgDefaultVoiceNumber)
}

// optional uint64 discoveryPageCtrlFlag = 59;
inline bool UserInfoExt::_internal_has_discoverypagectrlflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool UserInfoExt::has_discoverypagectrlflag() const {
  return _internal_has_discoverypagectrlflag();
}
inline void UserInfoExt::clear_discoverypagectrlflag() {
  _impl_.discoverypagectrlflag_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline uint64_t UserInfoExt::_internal_discoverypagectrlflag() const {
  return _impl_.discoverypagectrlflag_;
}
inline uint64_t UserInfoExt::discoverypagectrlflag() const {
  // @@protoc_insertion_point(field_get:UserInfoExt.discoveryPageCtrlFlag)
  return _internal_discoverypagectrlflag();
}
inline void UserInfoExt::_internal_set_discoverypagectrlflag(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.discoverypagectrlflag_ = value;
}
inline void UserInfoExt::set_discoverypagectrlflag(uint64_t value) {
  _internal_set_discoverypagectrlflag(value);
  // @@protoc_insertion_point(field_set:UserInfoExt.discoveryPageCtrlFlag)
}

// -------------------------------------------------------------------

// GetProfileResponse

// required .BaseResponse baseResponse = 1;
inline bool GetProfileResponse::_internal_has_baseresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.baseresponse_ != nullptr);
  return value;
}
inline bool GetProfileResponse::has_baseresponse() const {
  return _internal_has_baseresponse();
}
inline const ::BaseResponse& GetProfileResponse::_internal_baseresponse() const {
  const ::BaseResponse* p = _impl_.baseresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::BaseResponse&>(
      ::_BaseResponse_default_instance_);
}
inline const ::BaseResponse& GetProfileResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:GetProfileResponse.baseResponse)
  return _internal_baseresponse();
}
inline void GetProfileResponse::unsafe_arena_set_allocated_baseresponse(
    ::BaseResponse* baseresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseresponse_);
  }
  _impl_.baseresponse_ = baseresponse;
  if (baseresponse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GetProfileResponse.baseResponse)
}
inline ::BaseResponse* GetProfileResponse::release_baseresponse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BaseResponse* temp = _impl_.baseresponse_;
  _impl_.baseresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BaseResponse* GetProfileResponse::unsafe_arena_release_baseresponse() {
  // @@protoc_insertion_point(field_release:GetProfileResponse.baseResponse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BaseResponse* temp = _impl_.baseresponse_;
  _impl_.baseresponse_ = nullptr;
  return temp;
}
inline ::BaseResponse* GetProfileResponse::_internal_mutable_baseresponse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.baseresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::BaseResponse>(GetArenaForAllocation());
    _impl_.baseresponse_ = p;
  }
  return _impl_.baseresponse_;
}
inline ::BaseResponse* GetProfileResponse::mutable_baseresponse() {
  ::BaseResponse* _msg = _internal_mutable_baseresponse();
  // @@protoc_insertion_point(field_mutable:GetProfileResponse.baseResponse)
  return _msg;
}
inline void GetProfileResponse::set_allocated_baseresponse(::BaseResponse* baseresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseresponse_);
  }
  if (baseresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseresponse));
    if (message_arena != submessage_arena) {
      baseresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.baseresponse_ = baseresponse;
  // @@protoc_insertion_point(field_set_allocated:GetProfileResponse.baseResponse)
}

// required .ModUserInfo userInfo = 2;
inline bool GetProfileResponse::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool GetProfileResponse::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void GetProfileResponse::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ModUserInfo& GetProfileResponse::_internal_userinfo() const {
  const ::ModUserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ModUserInfo&>(
      ::_ModUserInfo_default_instance_);
}
inline const ::ModUserInfo& GetProfileResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:GetProfileResponse.userInfo)
  return _internal_userinfo();
}
inline void GetProfileResponse::unsafe_arena_set_allocated_userinfo(
    ::ModUserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GetProfileResponse.userInfo)
}
inline ::ModUserInfo* GetProfileResponse::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ModUserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ModUserInfo* GetProfileResponse::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:GetProfileResponse.userInfo)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ModUserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::ModUserInfo* GetProfileResponse::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModUserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::ModUserInfo* GetProfileResponse::mutable_userinfo() {
  ::ModUserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:GetProfileResponse.userInfo)
  return _msg;
}
inline void GetProfileResponse::set_allocated_userinfo(::ModUserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:GetProfileResponse.userInfo)
}

// required .UserInfoExt userInfoExt = 3;
inline bool GetProfileResponse::_internal_has_userinfoext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfoext_ != nullptr);
  return value;
}
inline bool GetProfileResponse::has_userinfoext() const {
  return _internal_has_userinfoext();
}
inline void GetProfileResponse::clear_userinfoext() {
  if (_impl_.userinfoext_ != nullptr) _impl_.userinfoext_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::UserInfoExt& GetProfileResponse::_internal_userinfoext() const {
  const ::UserInfoExt* p = _impl_.userinfoext_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserInfoExt&>(
      ::_UserInfoExt_default_instance_);
}
inline const ::UserInfoExt& GetProfileResponse::userinfoext() const {
  // @@protoc_insertion_point(field_get:GetProfileResponse.userInfoExt)
  return _internal_userinfoext();
}
inline void GetProfileResponse::unsafe_arena_set_allocated_userinfoext(
    ::UserInfoExt* userinfoext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfoext_);
  }
  _impl_.userinfoext_ = userinfoext;
  if (userinfoext) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GetProfileResponse.userInfoExt)
}
inline ::UserInfoExt* GetProfileResponse::release_userinfoext() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::UserInfoExt* temp = _impl_.userinfoext_;
  _impl_.userinfoext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserInfoExt* GetProfileResponse::unsafe_arena_release_userinfoext() {
  // @@protoc_insertion_point(field_release:GetProfileResponse.userInfoExt)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::UserInfoExt* temp = _impl_.userinfoext_;
  _impl_.userinfoext_ = nullptr;
  return temp;
}
inline ::UserInfoExt* GetProfileResponse::_internal_mutable_userinfoext() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.userinfoext_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserInfoExt>(GetArenaForAllocation());
    _impl_.userinfoext_ = p;
  }
  return _impl_.userinfoext_;
}
inline ::UserInfoExt* GetProfileResponse::mutable_userinfoext() {
  ::UserInfoExt* _msg = _internal_mutable_userinfoext();
  // @@protoc_insertion_point(field_mutable:GetProfileResponse.userInfoExt)
  return _msg;
}
inline void GetProfileResponse::set_allocated_userinfoext(::UserInfoExt* userinfoext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfoext_;
  }
  if (userinfoext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfoext);
    if (message_arena != submessage_arena) {
      userinfoext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfoext, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.userinfoext_ = userinfoext;
  // @@protoc_insertion_point(field_set_allocated:GetProfileResponse.userInfoExt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_UserInfo_2eproto
